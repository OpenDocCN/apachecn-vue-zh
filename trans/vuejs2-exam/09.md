

# 九、使用 Vue 路由器动态路由加载数据

在[第 8 章](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c)、*介绍 Vue 路由器和加载基于 URL 的组件*中，我们探讨了 Vue 路由器及其性能和功能。有了这些知识，我们现在可以继续用 Vue 来制作我们的商店了。在我们进入代码并开始创建之前，我们应该首先计划我们的商店将如何工作，我们需要什么 URL，以及我们需要制作什么组件。一旦我们设计好应用，我们就可以继续创建产品页面了。

在本章中，我们将:

*   概述我们的组件和路线，并创建占位符文件
*   加载产品 CSV 文件，对其进行处理，并缓存在 Vuex 中
*   用图片和产品变化创建一个单独的产品页面



# 概述和规划你的应用

首先，我们来思考一下 app 整体和用户流量。

我们将创建一个没有支付处理网关的商店。商店主页将显示精选的产品列表。用户将能够使用类别浏览产品，并使用我们制作的过滤器缩小选择范围。他们将能够选择一种产品，并查看关于它的更多详细信息。该产品将有变化(大小，颜色等)，并可能有几个产品图像。用户将能够添加一个变化到他们的篮子。从那里，他们可以继续浏览产品并添加更多到他们的篮子里，或者继续结账，在那里他们将被要求输入他们的姓名和地址，并付款。将显示订单确认画面。

整个商店应用将在 Vue 中创建，并将在客户端运行。这不包括支付、用户账户、股票管理或验证所需的任何服务器端代码。

该应用将使用 Vue-router 处理 URL，使用 Vuex 存储产品、购物篮内容和用户详细信息。



# 成分

有了大致的用户流程，我们需要计划为我们的商店制造哪些组件，以及它们的名称。这有助于开发应用，因为我们清楚地知道我们需要创建什么组件。我们还将决定组件的名称。遵循 Vue 风格指南([https://vuejs.org/v2/style-guide/index.html](https://vuejs.org/v2/style-guide/index.html))，我们所有的组件将由两个名字组成。



# 路由组件

以下组件将与 Vue-router 结合使用，构成我们应用的页面:

*   **店铺主页** — `HomePage`:店铺主页会显示一个由店主策划的商品列表。这将使用预先选择的产品句柄列表来显示。
*   **分类页面** — `CategoryPage`:列出特定分类的产品。类别列表页面也将有过滤器。
*   **产品页面** — `ProductPage`:产品页面将显示产品的详细信息、图片以及产品的变体。
*   **购物篮** — `OrderBasket`:在购物篮中，用户将能够查看他们添加的产品，删除不需要的商品，并更改每个商品的数量。它还会显示订单的总成本。
*   **收银台** — `OrderCheckout`:收银台将锁定购物篮，取消移除和更新产品的能力，并将有一个用户输入地址的表单。
*   **订单确认** — `OrderConfirmation`:该组件在下订单后显示，确认所购买的产品、送货地址、总价。
*   `404` **页面** — `PageNotFound`:输入错误网址时的错误页面。



# HTML 组件

HTML 组件将在页面组件中使用，以帮助减少重复布局代码中的重复:

*   **列表中的产品** — `ListProducts`:这将在列表视图中查看时显示产品的分页列表——例如在`HomePage`或`CategoryPage`组件中。
*   **类别列表** — `ListCategories`:这将创建一个用于导航的类别列表。
*   **购买清单** — `ListPurchases`:该组件会出现在购物篮、结账、订单确认页面；它会以表格形式列出产品，详细说明变化、价格和数量。它还会显示篮子中所有产品的总价。
*   **过滤** — `ProductFiltering`:一个用在分类页面侧面的组件将为用户提供过滤的能力，并将更新 URL，使用我们在[第 8 章](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=103&action=edit#post_93) 、 *介绍 Vue-Router 和加载基于 URL 的组件中介绍的 GET 参数。*



# 小路

有了概述的组件，我们就可以规划到我们商店的路径和 URL，以及它们将要采取的组件或动作。我们还需要考虑错误的 URL，以及我们是否应该将用户重定向到合适的位置或显示错误消息:

*   `/` : `Home`
*   `/category/:slug` : `CategoryPage`，使用`:slug`唯一标识符来标识要展示的产品
*   `/category`:这将重定向到`/`
*   `/product/:slug`:`ProductPage`–再次使用`:slug`来识别产品
*   `/product`:这将重定向到`/`
*   `/basket` : `OrderBasket`
*   `/checkout`:`OrderCheckout`–但是，如果没有产品，它会将用户重定向到`/basket`
*   `/complete`:`OrderConfirmation`-如果用户不是来自 `OrderCheckout`组件，那么他们将被重定向到``/basket``
*   `*`:`PageNotFound`–这将捕捉任何未指定的路线

决定好路线和组件后，我们就可以开始创建应用了。



# 创建初始文件

使用上一节中概述的应用，我们可以为我们的文件结构和组件创建框架。由于这个应用是一个大规模的应用，我们将把我们的文件分成每个组件的单独文件。这意味着我们的文件更易于管理，我们的主要应用 JavaScript 文件不会失控。

虽然对于开发来说可以接受，但部署具有如此数量文件的应用可能会增加您的加载时间，具体取决于您的服务器设置。使用传统的 HTTP/1.1，浏览器必须请求并加载每个文件——如果有多个文件，这是一个障碍。但是，使用 HTTP/2，您可以同时向用户推送几个文件——在这种情况下，多个文件可以在一定程度上提高您的应用的性能。

无论您选择在部署中使用哪种方法，都强烈建议您在将代码部署到生产环境时缩减 JavaScript。这确保了您的代码在提供给用户时尽可能的小:

 ![](../images/00018.jpeg)

为每个组件、视图和库创建一个文件，例如 Vue、Vuex 和 Vue-router。然后，为每种类型的文件创建一个文件夹。最后，添加一个`app.js`—这是库将被初始化的地方。

You may also consider using the vue-cli [(https://github.com/vuejs/vue-cli)](https://github.com/vuejs/vue-cli) for building your app. Beyond the scope of this book, as we only cover building a Vue app using the included JavaScript files, the vue-cli application allows you to develop your app in a more modular way and, once developed, deploy it in a similar fashion to how we have been developing the app.

创建一个`index.html`并包含您的 JavaScript 文件，确保 Vue 首先加载，您的应用的 JavaScript 最后加载。为你的应用添加一个容器，形成我们商店的视图:

```
<!DOCTYPE html>
<html>
<head>
  <title>Vue Shop</title>
</head>
<body>
  <div id="app"></div>

  <!-- Libraries -->
  <script type="text/javascript" src="js/libs/vue.js"></script>
  <script type="text/javascript" src="js/libs/vuex.js"></script>
  <script type="text/javascript" src="js/libs/router.js"></script>

  <!-- Components -->
  <script src="js/components/ListCategories.js"></script>
  <script src="js/components/ListProducts.js"></script>
  <script src="js/components/ListPurchases.js"></script>
  <script src="js/components/ProductFiltering.js"></script>

  <!-- Views -->
  <script src="js/views/PageNotFound.js"></script>
  <script src="js/views/CategoryPage.js"></script>
  <script src="js/views/HomePage.js"></script>
  <script src="js/views/OrderBasket.js"></script>
  <script src="js/views/OrderCheckout.js"></script>
  <script src="js/views/OrderConfirmation.js"></script>
  <script src="js/views/ProductPage.js"></script>

  <!-- App -->
  <script type="text/javascript" src="js/app.js"></script>
</body>
</html>
```

Ensure the `PageNotFound` component is loaded first, as we are going to be utilizing it within other components, as well as specifying it as the 404 page in our routes.

在每个文件中，通过声明一个变量或者使用`Vue.component`来初始化组件的类型。对于视图，也添加一个`name`属性——以帮助稍后的调试。

例如，位于`js/components/`文件夹中的所有文件都应该像下面这样初始化。请确保这些组件是小写的并且用连字符连接:

```
Vue.component('list-products', {

});
```

而位于`js/views`中的路线和视图的组件应该如下所示:

```
const OrderConfirmation = {
name: 'OrderConfirmation'
};
```

最后一步是初始化我们的 Vuex 商店、Vue 路由器和 Vue 应用。打开`app.js`并初始化库:

```
const store = new Vuex.Store({});

const router = new VueRouter({});

new Vue({
  el: '#app',

  store,
  router
});
```

Vue 组件和路线准备就绪，我们的商店、路线和应用已初始化，让我们看看如何设置服务器(如果需要)和加载数据。



# 服务器设置

对于我们的商店，我们将在页面加载中加载产品的 CSV。这将模拟从销售点系统的数据库或 API 中收集库存和产品数据，这是实体店的网上商店可能必须处理的事情。

与本书前面的 Dropbox 应用类似，我们将加载外部数据并将其保存到 Vuex 商店中。然而，我们将面临的问题是当通过 JavaScript 加载资源时；浏览器要求被请求文件的协议是通过 HTTP，HTTPS，或者是 CORS 请求。

这意味着我们无法使用 Dropbox API 使用的`fetch()`技术加载*本地*文件，因为当在浏览器中查看我们的应用时，我们正在通过`file://`协议加载本地资产。

我们可以用几种不同的方式来解决这个问题，具体选择哪种方式取决于您的具体情况。我们将加载一个 CSV 文件，并使用两个插件，将其转换成一个可用的 JSON 对象。您有三种选择:

1.  将文件存储在本地
2.  使用远程服务器或
3.  使用本地服务器

让我们看一下每个选项，以及每个选项的优点和缺点。



# 将文件存储在本地

第一种选择是将 CSV 适当地转换成 JSON，然后将输出保存在一个文件中。您需要将它赋给文件中的一个变量，并在库之前加载 JSON。一个例子可能是创建一个`data.json`并更新它以赋给一个变量:

```
const products = {...}
```

然后，您可以在 HTML 中加载 JSON 文件:

```
<script type="text/javascript" src="data.json"></script>
```

然后在您的`app.js`中有了可用的`products`变量。

优势:

*   减少代码中的负载
*   无需加载处理 CSV 所需的额外文件
*   不需要额外的步骤

缺点:

*   不模拟真实世界
*   如果您想要更新 CSV 数据，您需要转换、保存并赋值给一个变量



# 使用远程服务器

另一个选择是将文件上传到一个远程的现有服务器上，并在那里开发你的应用。

优势:

*   模拟加载 CSV 的真实开发
*   可以在任何地方用任何机器开发

缺点:

*   可能会很慢
*   需要连接到互联网
*   需要在实时服务器上设置部署过程或编辑文件



# 设置本地服务器

最后一个选项是在您的机器上设置一个本地服务器。有几个小的、轻量级的、零配置的模块和应用，或者还有更大、更强大的应用。如果您的机器上安装了 npm，推荐使用 node HTTP 服务器。如果没有，还有其他选择。

另一种选择是使用更重量级的应用，它可以为您提供 SQL 数据库和运行 PHP 应用的能力。这方面的一个例子是 MAMP 或 XAMPP。

优势:

*   模拟加载 CSV 的真实开发
*   快速、即时更新
*   可以离线开发

缺点:

*   需要安装软件
*   可能需要一些配置和/或命令行知识

我们要选择的选项是最后一个，使用 HTTP 服务器。让我们加载并处理 CSV，这样我们就可以开始创建我们的商店。



# 正在加载 CSV

为了模拟从商店数据库或销售点收集数据，我们的应用将从 CSV 加载产品数据。CSV 或逗号分隔值是一种文件格式，通常用于以数据库方式共享数据。想象一下您将如何在 excel 或 numbers 中编排产品列表:这就是 CSV 文件的格式。

下一步需要下载并包含几个 JavaScript 文件。如果您在*服务器设置*部分选择了选项 1——将文件存储在本地的 JSON 文件中——您可以跳过这一步。

我们将使用的数据是来自 Shopify 的示例商店数据。这些 CSV 有广泛的产品类型选择和不同的数据，这将考验我们的 Vue 技能。Shopify 已经从 GitHub 资源库([https://GitHub . com/shopify partners/shopify-product-csvs-and-images](https://github.com/shopifypartners/shopify-product-csvs-and-images))提供了他们的示例数据供下载。下载您感兴趣的任何 CSV 文件，并将其保存在文件系统的`data/`文件夹中。对于这个应用，我将使用`bicycles.csv`文件。

如果不对逗号分隔和引号封装的值进行大量编码和处理，JavaScript 就无法本地加载和处理 CSV 文件。为了避免这本书偏离到如何加载、解析和处理 CSV 文件，我们将使用一个库来完成繁重的工作。有两个值得注意的库，CSV 解析器([https://github.com/okfn/csv.js](https://github.com/okfn/csv.js))和 D3([https://d3js.org/](https://d3js.org/))。CSV 解析器只做 CSV 解析，不做其他事情，而 d3 能够生成图表和数据可视化。

值得考虑哪一个最适合自己；CSV 解析器只给你的应用增加了 3 KB 多一点的重量，而 d3 大约是 60 KB。除非您预计以后会添加可视化，否则建议您使用较小的库——尤其是当它们执行相同的功能时。然而，我们将运行两个库的例子。

我们希望在应用加载时加载我们的产品数据，这样我们的 CSV 将在组件需要数据时被加载和解析。因此，我们将在 Vue 的`created()`方法中加载我们的数据。



# 用 d3 加载 CSV

两个插件加载数据的方式非常相似，但是返回的数据略有不同——然而，一旦我们加载了数据，我们就会处理这个问题。

加载 d3 库——如果你想尝试一下，你可以使用托管版本:

```
<script src="https://d3js.org/d3.v4.min.js"></script>
```

使用 d3，我们在`csv()`的`d3`对象上使用一个函数，它接受一个参数 CSV 文件的路径。将`created()`函数添加到您的 Vue 实例中，并初始化 CSV 加载程序:

```
new Vue({
  el: '#app',

  store,
  router,

  created() {
    d3.csv('./data/csv-files/bicycles.csv', (error, data) => {
 console.log(data);
 });
  }
});
```

Remember the path to your file is relative to the HTML file which is including your JavaScript file – in this case, `index.html`.

在浏览器中打开文件不会呈现任何输出。但是，如果您打开 Javascript 控制台并展开正在输出的对象，您将看到类似于以下内容的内容:

![](../images/00019.jpeg)

这为您提供了一个`key: value`格式的每个产品的所有可用属性的细分。这使我们能够使用每个产品上的一致的`key`来访问每个红色的`value`。例如，如果我们想从上面的产品中得到`15mm-combo-wrench`，我们可以使用`Handle`键。这方面的更多内容将在后面介绍



# 使用 CSV 解析器加载 CSV

CSV 解析器的工作方式略有不同，因为它可以接受许多不同的参数，并且该库包含几个不同的方法和函数。数据输出也是不同的格式，提供了一个表格/CSV 样式的结构，带有一个`headers`和`fields`对象:

```
new Vue({
  el: '#app',

  store,
  router,

  created() {
    CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
 console.log(data);
 });
  }
});
```

这次查看输出会发现一个非常不同的结构，需要将字段的`key`与`headers`对象的索引相匹配。



# 统一 Shopify CSV 数据

在我们可以保存和利用 Shopify 数据之前，我们需要统一数据并将其处理为更易于管理的状态。如果您检查任一库输出的数据，您会注意到产品的每个变体或附加图像都有一个条目，句柄是每个条目之间的链接因素。例如，大约有 12 个句柄为 `pure-fix-bar-tape`的条目，每一个都有不同的颜色。理想情况下，我们希望每个变化都分组在同一项目下，也将图像显示为一个产品的列表。

Shopify CSV 数据的另一个问题是，字段标题的标点和语法不是很好的对象键。理想情况下，对象键应该像 URL slugs 一样，小写并且不包含空格。例如，`Variant Inventory Qty`理想上应该是`variant-inventory-qty` 。

为了避免我们自己手动处理数据和更新密钥，我们可以使用一个 Vue 插件来处理来自加载库的输出，并返回一个完全按照我们想要的方式格式化的产品对象。该插件名为`vue-shopify-products`，可从 unpkg 获得:

```
https://unpkg.com/vue-shopify-products
```

下载该库并将其包含到您的`index.html`文件中。下一步是告诉 Vue 使用这个插件——在你的`app.js`文件的顶部，包含下面一行:

```
Vue.use(ShopifyProducts);
```

这现在公开了一个关于 Vue 实例`$formatProducts()`的新方法，它允许我们传递 CSV 加载库的输出并获得一个更有用的对象集合:

```
Vue.use(ShopifyProducts);

const store = new Vuex.Store({});

const router = new VueRouter({});

new Vue({
  el: '#app',

  store,
  router,

  created() {
    CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
      let products = this.$formatProducts(data);
      console.log(products);
    });
  }
});
```

检查输出现在显示了按`handle`分组的集合，以变体和图像作为对象:

![](../images/00020.jpeg)

随着我们的产品分组更加有效，我们可以根据需要继续存储和召回。



# 储存产品

一旦我们检索并格式化了 CSV 数据，我们就可以在 Vuex 存储中缓存内容。这将通过一个简单的突变来完成，该突变获取一个有效载荷并不加任何修改地存储它。

在您的商店中创建一个`state`和`mutations`对象。在`state`中添加一个`products`的按键作为对象，在`mutations`对象中创建一个函数，也命名为`products`。变异应该接受两个参数——状态和有效载荷:

```
const store = new Vuex.Store({
  state: {
    products: {}
  },

  mutations: {
    products(state, payload) {

    }
  }
});
```

将`state.products`对象更新为`payload`的内容:

```
const store = new Vuex.Store({
  state: {
    products: {}
  },

  mutations: {
    products(state, payload) {
      state.products = payload;
    }
  }
});
```

用提交函数替换主 Vue 实例中的`console.log`,调用新的变异并传入格式化的产品数据:

```
new Vue({
  el: '#app',

  store,
  router,

  created() {
    CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
      let products = this.$formatProducts(data);
      this.store.commit('products', products);
    });
  }
});
```

通过将`$formatProducts`函数直接传递给 store `commit()`函数，而不是将其存储为一个变量，可以在一定程度上减少这种情况:

```
new Vue({
  el: '#app',

  store,
  router,

  created() {
    CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
      this.$store.commit('products', this.$formatProducts(data));
    });
  }
});
```



# 展示单一产品

随着数据的存储，我们现在可以开始制作组件并在前端显示内容。我们将从制作产品视图开始，展示产品细节、变化和图片。我们将在[第 10 章](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c)、*建立电子商务商店-浏览产品*中继续创建类别列表页面。

制作我们的产品视图的第一步是创建路线，允许组件通过 URL 显示。回头参考我们在本章开始时的笔记，产品组件将被加载到`/product/:slug`路径上。

在您的 Vue 路由器中创建一个`routes`数组，指定路径和组件:

```
const router = new VueRouter({
  routes: [
 {
      path: '/product/:slug', 
      component: ProductPage
    }
 ]
});
```

解释完`products`对象的布局后，我们可以开始理解路线和产品是如何链接的。我们将把产品的句柄传递给 URL 。这将选择带有该手柄的产品并显示数据。这意味着我们不需要显式地链接`slug`和`products`。



# 找不到页面

创建了第一个路由后，我们还应该创建我们的`PageNotFound`路由，以捕获任何不存在的 URL。当没有匹配的产品时，我们也可以重定向到这个页面。

我们将以与之前略有不同的方式创建`PageNotFound`组件。我们将创建一个`/404`路径作为命名路由，而不是将组件放在`*`上。这允许我们根据需要别名和重定向几个不同的路由。

将一个新对象添加到 routes 数组中，将`/404`作为路径，将`PageNotFound`组件作为指定组件。为您的路线添加一个名称，以便我们在需要时可以使用，最后，添加一个`alias`属性，它包含我们的全局、包罗万象的路线。

不要忘记将这个*放在 routes 数组的末尾*,以捕捉任何先前未指定的路线。添加新路线时，务必记住将其放在`PageNotFound`路线之前:

```
const router = new VueRouter({
  routes: [
    {
      path: '/product/:slug', 
      component: ProductPage
    },

    {
 path: '/404', 
 alias: '*',
 component: PageNotFound
 }
  ]
});
```

向您的`PageNotFound`组件添加一个模板。现在，给它一些基本的内容-我们可以在以后改进它，一旦我们有了应用的其余部分:

```
const PageNotFound = {
  name: 'PageNotFound',
  template: `<div>
 <h1>404 Page Not Found</h1>
 <p>Head back to the <router-link to="/">home page</router-link> and start again.</p>
 </div>`
};
```

请注意内容中路由器链接的使用。启动我们的应用需要做的最后一件事是在应用中添加`<router-view>`元素。前往视图，并将其包含在应用空间中:

```
<div id="app">
  <router-view></router-view>
</div> 
```

在浏览器中加载应用，如果需要，不要忘记启动 HTTP 服务器。首先，您应该看到您的`PageNotFound`组件内容。导航到以下产品 URL 应该会导致 JavaScript 错误，而不是`404`页面。这表明路由正确地选择了 URL，但错误是因为我们的`ProductPage`组件不包含模板:

```
#/product/15mm-combo-wrench
```

如果您看到了`PageNotFound`组件，请检查您的路线代码，因为这意味着`ProductPage`路线没有被选取。



# 选择正确的产品

设置好初始路线后，我们现在可以继续装载所需的产品并显示来自商店的信息。打开`views/Product.js`并创建一个模板密钥。首先，创建一个简单的`<div>`容器来显示产品的标题:

```
const ProductPage = {
  name: 'ProductPage',
  template: `<div>{{ product.title }}</div>`
};
```

在浏览器中查看它会立即抛出一个 JavaScript 错误，因为 Vue 期望`product`变量是一个对象——但是它目前是未定义的，因为我们还没有声明它。尽管目前解决这个问题似乎相当简单，但我们需要考虑产品尚未定义的情况。

我们的商店应用异步加载数据 CSV。这意味着在加载产品时，应用其余部分的执行不会停止。总的来说，这提高了我们的应用的速度。当我们有产品时，我们可以开始操作和显示列表，而不用等待应用的其余部分启动。

因此，用户很有可能在没有加载产品列表的情况下，通过共享的链接或搜索结果访问产品详细信息页面。为了防止应用在没有完全初始化的情况下试图显示产品数据，请在试图显示其任何属性之前，向模板添加一个条件属性来检查产品变量是否存在。

当加载我们的产品数据时，我们可以确保产品变量被设置为`false`，直到所有东西都被完全加载。将`v-if`属性添加到模板中的包含元素:

```
const ProductPage = {
  name: 'ProductPage',
  template: `<div v-if="product">{{ product.title }}</div>`
};
```

我们现在可以开始从商店加载正确的产品，并将其分配给一个变量。

创建一个内部带有`product()`函数的`computed`对象。在其中，创建一个产品的空白变量，然后返回它。现在默认返回`false`，这意味着我们的模板不会生成`<div>`:

```
const ProductPage = {
  name: 'ProductPage',
  template: `<div v-if="product">{{ product.title }}</div>`,

  computed: {
    product() {
 let product;

 return product;
 }
  }
};
```

选择产品现在是一个相当简单的过程，这要感谢我们格式化的产品商店和在`Product`组件中可用的`slug`变量。存储中的`products`对象被格式化为句柄作为键，而`product details`对象作为值。考虑到这一点，我们可以使用方括号格式选择所需的产品。例如:

```
products[handle]
```

使用 router `params`对象，从商店加载所需的产品，并将其分配给要返回的`product`变量:

```
const ProductPage = {
  name: 'ProductPage',
  template: `<div v-if="product">{{ product.title }}</div>`,

  computed: {
    product() {
      let product;

      product = this.$store.state.products[this.$route.params.slug];

      return product;
    }
  }
};
```

我们不直接给`product`赋值的原因是我们可以添加一些条件语句。为了确保我们只在商店有可用数据的情况下加载产品，我们可以添加一个`if()`语句来确保产品的对象有可用的键；换句话说，数据加载了吗？

添加一个`if`语句来检查商店产品密钥的长度。如果存在，将存储中的数据分配给要返回的`product`变量:

```
const ProductPage = {
  name: 'ProductPage',
  template: `<div v-if="product">{{ product.title }}</div>`,

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {
        product = this.$store.state.products[this.$route.params.slug];
      }

      return product;
    }
  }
};
```

现在在浏览器中查看应用，一旦数据加载完毕，您将看到产品的标题。这应该只需要一瞬间就可以加载，并且应该由我们的`if`语句优雅地处理。

在继续显示我们所有的产品数据之前，我们需要处理 URL 中不存在带有句柄的产品的情况。因为我们的`ProductPage`路由选择 URL 中`/product`之后的任何内容，所以不能使用`PageNotFound`通配符路径——因为是我们的`ProductPage`组件加载数据并确定产品是否存在。



# 捕捉未找到的产品

为了在产品不可用时显示`PageNotFound`页面，我们将使用我们的`ProductPage`组件加载该组件，并有条件地显示它。

为此，我们需要注册组件，以便在模板中使用它。我们需要注册它，因为我们的`PageNotFound`组件当前作为一个对象而不是一个 Vue 组件存在(例如，当我们使用`Vue.component`时)。

向您的`ProductPage`组件添加一个`components`对象，并包含`PageNotFound`:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div v-if="product"><h1>{{ product.title }}</h1></div>`,

 components: {
 PageNotFound
 },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {
        product = this.$store.state.products[this.$route.params.slug];
      }

      return product;
    }
  }
};
```

这给了我们一个新的 HTML 元素，以`<page-not-found>`的形式使用。将这个元素添加到您的模板中现有的`<div>`之后。因为我们的模板需要一个根元素，所以将它们都包装在一个额外的容器中:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product"><h1>{{ product.title }}</h1></div>
    <page-not-found></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },
  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {
        product = this.$store.state.products[this.$route.params.slug];
      }

      return product;
    }
  }
};
```

在浏览器中查看将会呈现出`404`页面模板，一旦数据加载完毕，就会呈现出上面的产品标题。我们现在需要更新组件，以便在没有数据显示时只显示`PageNotFound`组件。我们可以使用带有`v-if`属性的现有产品变量，如果为 false，则显示如下错误消息:

```
<page-not-found v-if="!product"></page-not-found>
```

然而，这意味着如果用户在没有加载产品数据的情况下访问产品页面，他们将会在被产品信息替换之前看到 404 信息的闪现。这不是一个很好的用户体验，所以我们应该只在我们确定产品数据已经加载并且没有匹配项的情况下显示错误。

为了解决这个问题，我们将创建一个新的变量来决定组件是否显示。在`ProductPage`组件中创建一个数据函数，返回一个键为`productNotFound`的对象，设置为 false。向`<page-not-found>`元素添加一个`v-if`条件，对照新的`productNotFound`变量进行检查:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product"><h1>{{ product.title }}</h1></div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

 data() {
 return {
 productNotFound: false
 }
 },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {
        product = this.$store.state.products[this.$route.params.slug];
      }

      return product;
    }
  }
};
```

如果产品不存在，最后一步是将变量设置为`true`。因为我们只想在数据加载后这样做，所以将代码添加到`$store.state.products`检查中。我们已经将数据赋给了`product`变量，所以我们可以添加一个检查来查看这个变量是否存在——如果不存在，改变我们的`productNotFound`变量的极性:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product"><h1>{{ product.title }}</h1></div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {
        product = this.$store.state.products[this.$route.params.slug];

 if(!product) {
 this.productNotFound = true;
 }
      }

      return product;
    }
  }
};
```

尝试在 URL 的末尾输入一个错误的字符串——您应该会看到我们现在熟悉的`404`错误页面。



# 显示产品信息

有了我们的产品加载、过滤和错误捕捉功能，我们就可以继续显示我们产品所需的信息了。每个产品可能包含一个或多个图像，以及一个或多个变体和它们之间的任意组合，因此我们需要确保满足这些场景中的每一个。

要查看我们可用的数据，请在`return`前添加一个`console.log(product)`:

```
product() {
  let product;

  if(Object.keys(this.$store.state.products).length) {
    product = this.$store.state.products[this.$route.params.slug];
    if(!product) {
      this.productNotFound = true;
    }
  }

  console.log(product);
  return product;
}
```

打开 JavaScript 控制台，检查现在应该在那里的对象。熟悉可用的键和值。注意，`images`键是一个数组，`variations`键是一个对象，包含一个字符串和另一个数组。

在我们处理变化和图像之前，让我们输出简单的东西。我们需要记住的是，我们输出的每个字段可能并不存在于每个产品上——所以最好在必要的地方用条件标签将其包装起来。

从产品详情中输出`body`、`type`和`vendor.title`。在`vendor.title`和`type`前面加上它们是什么的描述，但是要确保你只渲染产品细节中存在的文本:

```
template: `<div>
  <div v-if="product">
    <h1>{{ product.title }}</h1>
    <div class="meta">
 <span>
 Manufacturer: <strong>{{ product.vendor.title }}</strong>
 </span>
 <span v-if="product.type">
 Category: <strong>{{ product.type }}</strong>
 </span>
 </div>
 {{ product.body }}
  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```

请注意，我们可以灵活地为类型和供应商添加更易于用户理解的名称。一旦我们设置了类别和过滤，我们就可以将供应商和类型链接到合适的产品列表。

在浏览器中查看它，会发现正文将所有 HTML 标签输出为文本——这意味着我们可以在页面上看到它们。如果您回想一下本书开头我们讨论输出类型的地方，我们需要使用`v-html`来告诉 Vue 将块呈现为原始 HTML:

```
template: `<div>
  <div v-if="product">
    <h1>{{ product.title }}</h1>
    <div class="meta">
      <span>
        Manufacturer: <strong>{{ product.vendor.title }}</strong>
      </span>
      <span v-if="product.type">
        Category: <strong>{{ product.type }}</strong>
      </span>
    </div>
    <div v-html="product.body"></div>
  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```



# 产品图片

下一步是输出我们产品的图像。如果您正在使用自行车 CSV 文件，一个很好的测试产品是`650c-micro-wheelset`–导航到该产品，因为它有四个图像。不要忘记回到你的原始产品，以检查它的工作与一个图像。

无论有一个图像还是 100 个图像，图像值总是一个数组，所以为了显示它们，我们总是需要做一个`v-for`。添加一个新的容器，并在图像中循环。给每张图片增加一个宽度，这样它就不会占据你的页面。

images 数组包含每个图像的一个对象。它有一个`alt`和`source`键，可以直接输入你的 HTML。但是，在某些情况下，会缺少`alt`值——如果是，请插入产品标题:

```
template: `<div>
  <div v-if="product">

    <div class="images" v-if="product.images.length">
 <template v-for="img in product.images">
 <img 
 :src="img.source" 
 :alt="img.alt || product.title" 
 width="100">
 </template>
 </div> 

    <h1>{{ product.title }}</h1>

    <div class="meta">
      <span>
        Manufacturer: <strong>{{ product.vendor.title }}</strong>
      </span>
      <span v-if="product.type">
        Category: <strong>{{ product.type }}</strong>
      </span>
    </div>

    <div v-html="product.body"></div>

  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```

随着我们的图像显示，这将是一个很好的除了创建一个画廊。商店通常展示一个大图像，下面是一组缩略图。然后点击每个缩略图替换主图像，这样用户可以更好地查看更大的图像。让我们重新创建那个功能。如果只有一张图片，我们还需要确保不显示缩略图。

我们这样做，通过设置一个图像变量到图像数组中的第一个图像，这是一个将形成大图像的图像。如果数组中有多个图像，我们将显示缩略图。然后，我们将创建一个 click 方法，用选定的图像更新图像变量。

在您的数据对象中创建一个新变量，并在产品加载后用图像数组中的第一个项目更新它。在尝试赋值之前，最好确保`images`键实际上是一个项目数组:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product">
      <div class="images" v-if="product.images.length">
        <template v-for="img in product.images">
          <img 
            :src="img.source" 
            :alt="img.alt || product.title" 
            width="100">
        </template>
      </div> 
      <h1>{{ product.title }}</h1>
      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
      </div>
      <div v-html="product.body"></div>
    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false,
      image: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.$route.params.slug];
        this.image = (product.images.length) ? product.images[0] : false;

        if(!product) {
          this.productNotFound = true;
        }
      }

      console.log(product);
      return product;
    }
  }
};
```

接下来，更新模板中现有的图像循环，使其仅在数组中有多个图像时显示。此外，将第一幅图像作为主图像添加到模板中，不要忘记先检查它是否存在:

```
template: `<div>
  <div v-if="product">

    <div class="images" v-if="image">
      <div class="main">
        <img 
 :src="image.source" 
 :alt="image.alt || product.title">
      </div>

      <div class="thumbnails" v-if="product.images.length > 1">
        <template v-for="img in product.images">
          <img 
            :src="img.source" 
            :alt="img.alt || product.title" 
            width="100">
        </template>
      </div>
    </div> 

    <h1>{{ product.title }}</h1>

    <div class="meta">
      <span>
        Manufacturer: <strong>{{ product.vendor.title }}</strong>
      </span>
      <span v-if="product.type">
        Category: <strong>{{ product.type }}</strong>
      </span>
    </div>

    <div v-html="product.body"></div>

  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```

最后一步是向每个缩略图添加一个 click 处理程序，以便在交互时更新 image 变量。由于图像本身没有`cursor: pointer` CSS 属性，所以可能值得考虑添加这个属性。

单击处理程序将是一个方法，它接受缩略图循环中的每个图像作为参数。单击时，它将简单地用传递的对象更新图像变量:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product">
      <div class="images" v-if="image">
        <div class="main">
          <img 
            :src="image.source" 
            :alt="image.alt || product.title">
        </div>

        <div class="thumbnails" v-if="product.images.length > 1">
          <template v-for="img in product.images">
            <img 
              :src="img.source" 
              :alt="img.alt || product.title" 
              width="100" 
              @click="updateImage(img)">
          </template>
        </div>
      </div> 

      <h1>{{ product.title }}</h1>

      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
      </div>

      <div v-html="product.body"></div>

    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false,
      image: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.$route.params.slug];
        this.image = (product.images.length) ? product.images[0] : false;

        if(!product) {
          this.productNotFound = true;
        }
      }

      console.log(product);
      return product;
    }
  },

  methods: {
 updateImage(img) {
 this.image = img;
 }
 }
};
```

在你的浏览器中加载产品，试着点击任何缩略图——你应该能够更新主图像。不要忘记在只有一张图片或者没有图片的产品上验证你的代码，以确保用户不会遇到任何错误。

Don't be afraid of whitespace and adding new lines for readability. Being able to easily understand your code is better than the few bytes you would have saved on file load. When deploying to production, files should be minified, but during development white space takes precedence.  <title>Product variations</title>  <link href="../stylesheet.css" rel="stylesheet" type="text/css"> <link href="../page_styles.css" rel="stylesheet" type="text/css">

# 产品差异

有了这个特殊的数据集，我们的每个产品至少包含一个变体，但也可以包含几个变体。这通常与图像的数量密切相关，但并不总是相关的。变化可以是颜色或大小。

在我们的 `Product` 对象上，我们有两个键来帮助我们显示变化。它们是 `variationTypes`，列出了尺寸和颜色等变量的名称，还有`variationProducts`，包含了所有的变量。对象`variationProducts`中的每个产品都有一个进一步的对象`variant`，它列出了所有可更改的属性。例如，如果一件夹克有两种颜色，每种颜色有三种尺寸，那么就会有六个`variationProducts`，每个都有两个`variant`属性。

每个产品都会包含至少一个变体，尽管如果只有一个变体，我们可能需要考虑产品页面的 UX。我们将在表格和下拉菜单中展示我们的产品变化，这样您就可以体验创建这两种元素的过程。



# 变体显示表

在您的产品模板中创建一个将显示变体的新容器。在这个容器中，我们可以创建一个表来显示产品的不同变化。这将通过`v-for`声明来实现。但是，现在您已经对功能更加熟悉了，我们可以引入一个新的属性。



# 使用带循环的钥匙

在 Vue 中使用循环时，建议您使用一个额外的属性来标识每个项目，`:key`。这有助于 Vue 在重新排序、排序或过滤时识别数组的元素。使用`:key`的一个例子是:

```
<div v-for="item in items" :key="item.id">
  {{ item.title }}
</div>
```

key 属性应该是该项本身的唯一属性，而不是该项在数组中的索引，以帮助 Vue 识别特定的对象。在[官方 Vue 文档](https://vuejs.org/v2/guide/list.html#key)中可以找到更多关于使用带环钥匙的信息。

在显示我们的变体时，我们将利用`key`属性，但是使用`barcode`属性。



# 在表格中显示变化

向变体容器中添加一个表格元素，并遍历`items`数组。现在，显示`title`、`quantity`和`price`。添加一个额外的单元格，该单元格包含一个值为 Add to basket 的按钮。我们将在[第 11 章](part0216.html#6DVPG0-985bf4ae118d4f62b18ae64204cb251c)、*构建一个电子商务商店-添加一个收银台中进行配置。不要忘记在你的价格前加上一个`$`货币符号，因为它目前只是一个“原始”数字。*

注意——当在模板文字中使用`$`符号时，JavaScript 会尝试将它和花括号一起解释为一个 JavaScript 变量。为了抵消这一点，在货币前面加上一个反斜杠——这告诉 JavaScript 下一个字符是文字，不应该以任何其他方式解释:

```
template: `<div>
  <div v-if="product">
    <div class="images" v-if="image">
      <div class="main">
        <img 
          :src="image.source" 
          :alt="image.alt || product.title">
      </div>

      <div class="thumbnails" v-if="product.images.length > 1">
        <template v-for="img in product.images">
          <img 
            :src="img.source" 
            :alt="img.alt || product.title" 
            width="100" 
            @click="updateImage(img)">
        </template>
      </div>
    </div> 

    <h1>{{ product.title }}</h1>

    <div class="meta">
      <span>
        Manufacturer: <strong>{{ product.vendor.title }}</strong>
      </span>
      <span v-if="product.type">
        Category: <strong>{{ product.type }}</strong>
      </span>
    </div>

    <div class="variations">
 <table>
 <tr v-for="variation in product.variationProducts" :key="variation.barcode">
 <td>{{ variation.quantity }}</td>
 <td>\${{ variation.price }}</td>
 <td><button>Add to basket</button></td>
 </tr>
 </table>
 </div>

    <div v-html="product.body"></div>

  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```

尽管我们显示了价格和数量，但是我们并没有输出变体的实际变体属性(比如颜色)。为此，我们需要用一个方法对我们的变体进行一些处理。

变体对象包含每个变体类型的子对象，每个类型都有一个名称和值。它们也与 slug 转换的密钥一起存储在对象中。更多详情见以下截图:

![](../images/00021.jpeg)

在表格的开头添加一个新的单元格，将变化传递给名为`variantTitle()`的方法:

```
<div class="variations">
  <table>
    <tr v-for="variation in product.variationProducts" :key="variation.barcode">
      <td>{{ variantTitle(variation) }}</td>
      <td>{{ variation.quantity }}</td>
      <td>\${{ variation.price }}</td>
      <td><button>Add to basket</button></td>
    </tr>
  </table>
</div>
```

在您的`methods`对象中创建新方法:

```
methods: {
  updateImage(img) {
    this.image = img;
  },

 variantTitle(variation) {

 }
}
```

我们现在需要构造一个带有变量标题的字符串，显示所有可用的选项。为此，我们将为每种类型构造一个数组，然后将它们连接成一个字符串。

将`variants`存储为一个变量，并创建一个空数组。我们现在可以遍历`variants`对象中可用的键，并创建一个字符串来输出。如果您决定将 HTML 添加到字符串中，如下例所示，我们将需要更新模板以输出 HTML 而不是原始字符串:

```
variantTitle(variation) {
  let variants = variation.variant,
 output = [];

 for(let a in variants) {
 output.push(`<b>${variants[a].name}:</b> ${variants[a].value}`);
 } 
}
```

我们的输出数组对于每个变量都有一个条目，格式如下:

```
["<b>Color:</b> Alloy", "<b>Size:</b> 49 cm"]
```

我们现在可以将每一个连接在一起，将输出从数组转换成字符串。您选择用什么字符、字符串或 HTML 来连接它取决于您自己。现在，使用两边都有空格的`/`。或者，您可以使用`</td><td>`标签来创建一个新的表格单元格。添加`join()`功能并更新模板以使用`v-html`:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product">
      <div class="images" v-if="image">
        <div class="main">
          <img 
            :src="image.source" 
            :alt="image.alt || product.title">
        </div>

        <div class="thumbnails" v-if="product.images.length > 1">
          <template v-for="img in product.images">
            <img 
              :src="img.source" 
              :alt="img.alt || product.title" 
              width="100" 
              @click="updateImage(img)">
          </template>
        </div>
      </div> 

      <h1>{{ product.title }}</h1>

      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
      </div>

      <div class="variations">
        <table>
          <tr v-for="variation in product.variationProducts" :key="variation.barcode">
            <td v-html="variantTitle(variation)"></td>
            <td>{{ variation.quantity }}</td>
            <td>\${{ variation.price }}</td>
            <td><button>Add to basket</button></td>
          </tr>
        </table>
      </div>

      <div v-html="product.body"></div>

    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false,
      image: false
    }
  },

  computed: {
    ...
  },

  methods: {
    updateImage(img) {
      this.image = img;
    },

    variantTitle(variation) {
      let variants = variation.variant,
        output = [];

      for(let a in variants) {
        output.push(`<b>${variants[a].name}:</b> ${variants[a].value}`);
      }

      return output.join(' / ');
    }

  }
};
```

将一个点击事件附加到添加到篮子按钮，并在组件上创建一个新方法。这个方法需要传入`variation`对象，这样就可以将正确的对象添加到篮子中。现在，添加一个 JavaScript `alert()`来确认你有正确的:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product">
      <div class="images" v-if="image">
        <div class="main">
          <img 
            :src="image.source" 
            :alt="image.alt || product.title">
        </div>

        <div class="thumbnails" v-if="product.images.length > 1">
          <template v-for="img in product.images">
            <img 
              :src="img.source" 
              :alt="img.alt || product.title" 
              width="100" 
              @click="updateImage(img)">
          </template>
        </div>
      </div> 

      <h1>{{ product.title }}</h1>

      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
      </div>

      <div class="variations">
        <table>
          <tr v-for="variation in product.variationProducts" :key="variation.barcode">
            <td v-html="variantTitle(variation)"></td>
            <td>{{ variation.quantity }}</td>
            <td>\${{ variation.price }}</td>
            <td><button @click="addToBasket(variation)">Add to basket</button></td>
          </tr>
        </table>
      </div>

      <div v-html="product.body"></div>

    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false,
      image: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.$route.params.slug];
        this.image = (product.images.length) ? product.images[0] : false;

        if(!product) {
          this.productNotFound = true;
        }
      }

      console.log(product);
      return product;
    }
  },

  methods: {
    updateImage(img) {
      this.image = img;
    },

    variantTitle(variation) {
      let variants = variation.variant,
        output = [];

      for(let a in variants) {
        output.push(`<b>${variants[a].name}:</b> ${variants[a].value}`);
      }

      return output.join(' / ');
    },

    addToBasket(variation) {
 alert(`Added to basket: ${this.product.title} - ${this.variantTitle(variation)}`);
 }

  }
};
```

注意警告框中使用的模板文字——这允许我们使用 Javascript 变量，而不必使用字符串连接技术。点击添加到购物篮按钮，将会弹出一个产品名称和所点击变化的列表。



# 在选择框中显示变体

产品页面上更常见的界面模式是有一个下拉列表或选择框，显示您的变化并可供选择。

当使用一个选择框时，我们会有一个默认选择的变体，或者是用户已经交互并特别选择的变体。因此，当用户更改选择框时，我们可以更改图像，并在产品页面上显示关于变体的其他信息，包括价格和数量。

我们不会依赖于将变量传递给`addToBasket`方法，因为它将作为产品组件上的一个对象存在。

将您的`<table>`元素更新为`<select>`，将`<tr>`更新为`<option>`。将按钮*移动到该元素的*之外，并从`click`事件中移除参数。从`variantTitle()`方法中移除任何 HTML。因为它现在位于选择框内，所以不需要:

```
<div class="variations">
 <select>
 <option 
 v-for="variation in product.variationProducts" 
 :key="variation.barcode" 
 v-html="variantTitle(variation)"
 ></option>
 </select>

  <button @click="addToBasket()">Add to basket</button>
</div>
```

下一步是创建一个可用于组件的新变量。与图像类似，这将通过`variationProducts`数组的第一项来完成，并在选择框改变时更新。

在数据对象中创建一个名为`variation`的新项目。当数据加载到`product`计算变量时，填充该变量:

```
const ProductPage = {
  name: 'ProductPage',

  template: `...`,

  components: {
    PageNotFound
  },

  data() {
    return {
      productNotFound: false,
      image: false,
      variation: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.$route.params.slug];

        this.image = (product.images.length) ? product.images[0] : false;
        this.variation = product.variationProducts[0];

        if(!product) {
          this.productNotFound = true;
        }
      }

      console.log(product);
      return product;
    }
  },

  methods: {
    ...
  }
};
```

更新`addToBasket`方法以使用`ProductPage`组件的`variation`变量，并且不依赖于参数:

```
addToBasket() {
  alert(`Added to basket: ${this.product.title} - ${this.variantTitle(this.variation)}`);
}
```

尝试点击添加到篮子按钮——它应该添加第一个变化，不管在下拉列表中选择什么。为了在变化时更新变量，我们可以将`variations`变量绑定到选择框——以同样的方式，我们在本书开始时做了文本框过滤。

向`select`元素添加一个`v-model`属性。我们还需要告诉 Vue 在选择时该绑定什么变量。默认情况下，它会做`<option>`的内容，这是目前我们定制的变体标题。但是，我们想绑定整个`variation`对象。向`<option>`元素添加一个`:value`属性:

```
<div class="variations">
  <select v-model="variation">
    <option 
      v-for="variation in product.variationProducts" 
      :key="variation.barcode" 
      :value="variation"
      v-html="variantTitle(variation)"
    ></option>
  </select>

  <button @click="addToBasket()">Add to basket</button>
</div>
```

更改选择框并点击添加到篮子按钮，现在将产生正确的变化。这种方法为我们在表格中显示变化提供了更多的灵活性。

它允许我们在产品的其他地方显示变化数据。尝试在`meta`容器内的产品标题和数量旁边添加价格:

```
template: `<div>
  <div v-if="product">
    <div class="images" v-if="image">
      <div class="main">
        <img 
          :src="image.source" 
          :alt="image.alt || product.title">
      </div>

      <div class="thumbnails" v-if="product.images.length > 1">
        <template v-for="img in product.images">
          <img 
            :src="img.source" 
            :alt="img.alt || product.title" 
            width="100" 
            @click="updateImage(img)">
        </template>
      </div>
    </div> 

    <h1>{{ product.title }} - \${{ variation.price }}</h1>

    <div class="meta">
      <span>
        Manufacturer: <strong>{{ product.vendor.title }}</strong>
      </span>
      <span v-if="product.type">
        Category: <strong>{{ product.type }}</strong>
      </span>
      <span>
 Quantity: <strong>{{ variation.quantity }}</strong>
 </span>
    </div>

    <div class="variations">
      <select v-model="variation">
        <option 
          v-for="variation in product.variationProducts" 
          :key="variation.barcode" 
          :value="variation"
          v-html="variantTitle(variation)"
        ></option>
      </select>

      <button @click="addToBasket()">Add to basket</button>
    </div>

    <div v-html="product.body"></div>

  </div>
  <page-not-found v-if="productNotFound"></page-not-found>
</div>`,
```

这两个新属性将在变更变体时更新。我们还可以将图像更新为所选的变体，如果它有变体的话。为此，向您的组件添加一个`watch`对象，该对象监视变化变量。更新后，我们可以检查变体是否有图像，如果有，用这个属性更新图像变量:

```
const ProductPage = {
  name: 'ProductPage',

  template: `...`,

  components: {
    ...
  },

  data() {
    ...
  },

  computed: {
    ...
  },

 watch: {
 variation(v) {
 if(v.hasOwnProperty('image')) {
 this.updateImage(v.image);
 }
 }
 },

  methods: {
    ...
  }
};
```

当使用`watch`时，该函数将新项目作为第一个参数传递。我们可以使用它来收集图像信息，而不是参考组件上的图像。

我们可以做的另一个改进是禁用添加到购物篮按钮，并在下拉列表中添加一个注释，如果变化缺货。该信息是从变量`quantity`键收集的。

检查数量，如果少于一个，在选择框中显示缺货消息，并使用`disabled` HTML 属性禁用添加到购物篮按钮。我们还可以更新按钮的值:

```
template: `<div>
    <div v-if="product">
      <div class="images" v-if="image">
        <div class="main">
          <img 
            :src="image.source" 
            :alt="image.alt || product.title">
        </div>

        <div class="thumbnails" v-if="product.images.length > 1">
          <template v-for="img in product.images">
            <img 
              :src="img.source" 
              :alt="img.alt || product.title" 
              width="100" 
              @click="updateImage(img)">
          </template>
        </div>
      </div> 

      <h1>{{ product.title }} - \${{ variation.price }}</h1>

      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
        <span>
          Quantity: <strong>{{ variation.quantity }}</strong>
        </span>
      </div>

      <div class="variations">
        <select v-model="variation">
          <option 
            v-for="variation in product.variationProducts" 
            :key="variation.barcode" 
            :value="variation"
            v-html="variantTitle(variation) + ((!variation.quantity) ? ' - out of stock' : '')"
          ></option>
        </select>

        <button @click="addToBasket()" :disabled="!variation.quantity">
          {{ (variation.quantity) ? 'Add to basket' : 'Out of stock' }}
        </button>
      </div>

      <div v-html="product.body"></div>

    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,
```

如果使用`bicycles.csv`数据集，Keirin Pro 轨道框架集产品(`/#/product/keirin-pro-track-frame`)包含几种变体，有些没有库存。这允许您随着图像变化测试`out of stock`功能。

我们可以对产品页面做的另一件事是，当有多个变体时，只显示下拉列表。只有一个的产品的例子是 15 mm 组合扳手 ( `#/product/15mm-combo-wrench`)。在这种情况下，不值得显示`<select>`框。当我们在加载时设置`Product`组件上的`variation`变量时，我们不依赖于选择来初始设置变量。因此，当只有一个替代产品时，我们可以完全移除带有`v-if=""`的选择框。

就像我们对图像所做的那样，检查数组的长度是否大于 1，这次是`variationProducts`数组:

```
<div class="variations">
  <select v-model="variation" v-if="product.variationProducts.length > 1">
    <option 
      v-for="variation in product.variationProducts" 
      :key="variation.barcode" 
      :value="variation"
      v-html="variantTitle(variation) + ((!variation.quantity) ? ' - out of stock' : '')"
    ></option>
  </select>

  <button @click="addToBasket()" :disabled="!variation.quantity">
    {{ (variation.quantity) ? 'Add to basket' : 'Out of stock' }}
  </button>
</div>
```

通过移除不需要的元素，我们现在有了一个更整洁的界面。



# 切换 URL 时更新产品详细信息

在浏览不同的产品 URL 以检查变化时，y 你可能已经注意到 点击后退和前进不会更新页面上的产品数据。

这是因为`Vue-router`意识到页面之间使用的是同一个组件，因此，它没有销毁和创建新的实例，而是重用了该组件。这样做的缺点是数据不会更新；我们需要触发一个函数来包含新产品数据。好处是代码效率更高。

为了告诉 Vue 检索新数据，我们需要创建一个`watch`函数；我们要观察的不是一个变量，而是`$route`变量。当这个更新时，我们可以加载新的数据。

在`slug`的数据实例中创建一个新变量，并将默认值设置为 route 参数。更新`product`计算函数以使用此变量代替路线:

```
const ProductPage = {
  name: 'ProductPage',

  template: `...`,

  components: {
    PageNotFound
  },

  data() {
    return {
      slug: this.$route.params.slug,
      productNotFound: false,
      image: false,
      variation: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.slug];

        this.image = (product.images.length) ? product.images[0] : false;
        this.variation = product.variationProducts[0];

        if(!product) {
          this.productNotFound = true;
        }
      }

      console.log(product);
      return product;
    }
  },

  watch: {
    ...
  },

  methods: {
    ...
  }
};
```

我们现在可以创建一个`watch`函数，关注`$route`变量。当这种情况发生变化时，我们可以更新`slug`变量，这又会更新正在显示的数据。

当观察一条路线时，该函数有两个参数传递给它:`to`和`from`。`to`变量包含了我们要去的路线的所有信息，包括参数和使用的组件。`from`变量包含当前路线的所有信息。

当路线改变时，通过将`slug`变量更新为新参数，我们强制组件使用来自存储的新数据进行重绘:

```
const ProductPage = {
  name: 'ProductPage',

  template: `<div>
    <div v-if="product">
      <div class="images" v-if="image">
        <div class="main">
          <img 
            :src="image.source" 
            :alt="image.alt || product.title">
        </div>

        <div class="thumbnails" v-if="product.images.length > 1">
          <template v-for="img in product.images">
            <img 
              :src="img.source" 
              :alt="img.alt || product.title" 
              width="100" 
              @click="updateImage(img)">
          </template>
        </div>
      </div> 

      <h1>{{ product.title }} - \${{ variation.price }}</h1>

      <div class="meta">
        <span>
          Manufacturer: <strong>{{ product.vendor.title }}</strong>
        </span>
        <span v-if="product.type">
          Category: <strong>{{ product.type }}</strong>
        </span>
        <span>
          Quantity: <strong>{{ variation.quantity }}</strong>
        </span>
      </div>

      <div class="variations">
        <select v-model="variation" v-if="product.variationProducts.length > 1">
          <option 
            v-for="variation in product.variationProducts" 
            :key="variation.barcode" 
            :value="variation"
            v-html="variantTitle(variation) + ((!variation.quantity) ? ' - out of stock' : '')"
          ></option>
        </select>

        <button @click="addToBasket()" :disabled="!variation.quantity">
          {{ (variation.quantity) ? 'Add to basket' : 'Out of stock' }}
        </button>
      </div>

      <div v-html="product.body"></div>

    </div>
    <page-not-found v-if="productNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  data() {
    return {
      slug: this.$route.params.slug,
      productNotFound: false,
      image: false,
      variation: false
    }
  },

  computed: {
    product() {
      let product;

      if(Object.keys(this.$store.state.products).length) {

        product = this.$store.state.products[this.slug];

        this.image = (product.images.length) ? product.images[0] : false;
        this.variation = product.variationProducts[0];

        if(!product) {
          this.productNotFound = true;
        }
      }

      return product;
    }
  },

  watch: {
    variation(v) {
      if(v.hasOwnProperty('image')) {
        this.updateImage(v.image);
      }
    },

    '$route'(to) {
 this.slug = to.params.slug;
 }
  },

  methods: {
    updateImage(img) {
      this.image = img;
    },

    variantTitle(variation) {
      let variants = variation.variant,
        output = [];

      for(let a in variants) {
        output.push(`${variants[a].name}: ${variants[a].value}`);
      }

      return output.join(' / ');
    },

    addToBasket() {
      alert(`Added to basket: ${this.product.title} - ${this.variantTitle(this.variation)}`);
    }

  }
};
```

完成产品页面后，我们可以继续为`type`和`vendor`变量创建类别列表。也删除代码中的任何`console.log()`调用，保持代码整洁。



# 摘要

这一章已经讲了很多。我们将产品的 CSV 文件加载并存储到我们的 Vuex 商店中。在那里，我们创建了一个产品详细信息页面，该页面在 URL 中使用一个动态变量来加载特定的产品。我们已经创建了一个产品详细信息视图，允许用户浏览图片集，并从下拉列表中选择一个变体。如果变体有关联的图像，则主图像会更新。

在[第十章](part0185.html#5GDO20-985bf4ae118d4f62b18ae64204cb251c)、*建立电子商务商店-浏览产品*、
我们将创建一个分类页面，创建过滤和订购功能-帮助用户找到他们想要的产品。