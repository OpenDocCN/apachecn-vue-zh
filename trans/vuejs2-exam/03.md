

# 优化您的应用程序并使用组件显示数据

在[第 2 章](part0031.html#TI1E0-985bf4ae118d4f62b18ae64204cb251c)、*显示、循环、搜索和过滤数据*中，我们让我们的 Vue 应用程序显示我们的人员目录，我们可以利用这个机会优化我们的代码，并将其分成组件。这使得代码更容易管理，更容易理解，并且使其他开发人员更容易解决数据流(或者您，当您几个月后回来查看您的代码时！).

本章将涵盖:

*   通过减少重复来优化我们的 Vue.js 代码，并从逻辑上组织我们的代码
*   如何创建 Vue 组件并在 Vue 中使用它们
*   如何将道具和插槽与组件一起使用
*   利用事件在组件之间传输数据



# 优化代码

当我们在解决问题的同时编写代码时，有一个时候你需要后退一步，看看你的代码来优化它。这可能包括减少变量和方法的数量或创建方法，以减少重复的功能。我们当前的 Vue 应用如下所示:

```
      const app = new Vue({
        el: '#app',
        data: {
          people: [...],
          currency: '$',
          filterField: '',
          filterQuery: '',
          filterUserState: ''
        },
        methods: {
          activeStatus(person) {
            return (person.isActive) ? 'Active' : 
             'Inactive';
          },
          activeClass(person) {
            return person.isActive ? 'active' : 
            'inactive';
          },
          balanceClass(person) {
            let balanceLevel = 'success';
            if(person.balance < 2000) {
              balanceLevel = 'error';
            } else if (person.balance < 3000) {
              balanceLevel = 'warning';
            }
            let increasing = false,
            balance = person.balance / 1000;
            if(Math.round(balance) == 
             Math.ceil(balance)) {
              increasing = 'increasing';
            }
            return [balanceLevel, increasing];
          },
          formatBalance(balance) {
            return this.currency + balance.toFixed(2);
          },
          formatDate(date) {
            let registered = new Date(date);
            return registered.toLocaleString('en-US');
          },
          filterRow(person) {
            let result = true;
            if(this.filterField) {
              if(this.filterField === 'isActive') {
                result = (typeof this.filterUserState 
                 === 'boolean') ? (this.filterUserState 
                 === person.isActive) : true;
              } else {
                let query = this.filterQuery,
                    field = person[this.filterField];
                if(typeof field === 'number') {
                  query.replace(this.currency, '');
                  try {
                    result = eval(field + query);
                  } catch(e) {}
                } else {
                  field = field.toLowerCase();
                  result =        
            field.includes(query.toLowerCase());
                }
              }
            }
            return result;
          },
          isActiveFilterSelected() {
            return (this.filterField === 'isActive');
          }
        }
      });
```

查看前面的代码，我们可以做一些改进。其中包括:

*   减少过滤变量的数量并进行逻辑分组
*   组合格式功能
*   减少硬编码变量和属性的数量
*   将方法重新排序，使其更符合逻辑

我们将分别讨论这些要点，这样我们就有了一个清晰的代码库来构建组件。



# 减少过滤变量的数量并进行逻辑分组

过滤目前使用了三个变量，`filterField`、`filterQuery`和`filterUserState`。目前链接这些变量的唯一东西是名称，而不是在它们自己的一个对象中系统地链接它们。这样做避免了关于它们是与同一个组件相关还是恰好相同的任何模糊性。在数据对象中，创建一个名为`filter`的新对象，并将每个变量移入:

```
      data: {
        people: [..],
        currency: '$',
        filter: {
          field: '',
          query: '',
          userState: '',
        }
      }
```

为了访问数据，更新`filterField`到`this.filter.field`的任何引用。注意这个额外的点，表示它是过滤器对象的一个键。不要忘记更新`filterQuery`和`filterUserState`的参考资料。例如，`isActiveFilterSelected`方法会变成:

```
      isActiveFilterSelected() {
        return (this.filter.field === 'isActive');
      }
```

您还需要更新视图中的`v-model`和`v-show`属性——各种变量出现了五次。

在更新过滤变量时，我们可以借此机会删除一个。使用我们当前的过滤，我们一次只能有一个过滤器处于活动状态。这意味着`query`和`userState`变量只在任何时候被使用，这给了我们组合这两个变量的机会。为此，我们需要更新视图和应用程序代码来满足这一需求。

从过滤器数据对象中移除`userState`变量，并将视图中出现的任何`filter.userState`更新为`filter.query`。现在在你的 Vue JavaScript 代码中为`filter.userState`做一个*查找并替换*，再次用`filter.query`替换它。

在浏览器中查看您的应用程序时，它最初似乎可以工作，能够按字段过滤用户。但是，如果您按状态筛选，然后切换到任何其他字段，查询字段将不会显示。这是因为使用单选按钮将值设置为布尔值，当试图将查询字段转换为小写时，会失败。为了解决这个问题，我们可以使用本地 JavaScript `String()`函数将`filter.query`变量中的任何值转换为字符串。这确保了我们的过滤功能可以处理任何过滤输入:

```
      if(this.filter.field === 'isActive') {
        result = (typeof this.filter.query ===        
       'boolean') ? (this.filter.query ===             
        person.isActive) : true;
         } else {
        let query = String(this.filter.query),
            field = person[this.filter.field];
           if(typeof field === 'number') {
           query.replace(this.currency, '');
          try {
            result = eval(field + query);
          } catch(e) {}
        } else {
          field = field.toLowerCase();
          result = field.includes(query.toLowerCase());
        }
```

现在，将这一点添加到我们的代码中可以确保无论值是多少，我们的查询数据都是可用的。现在产生的问题是当用户在要过滤的字段之间切换时。如果您选择了活动用户并选择了单选按钮，过滤会按预期工作，但是，如果您现在切换到电子邮件或另一个字段，输入框会预填充`true`或`false`。这会立即过滤，但通常不会返回任何结果。在两个文本过滤字段之间切换时也会出现这种情况，这不是我们想要的效果。

我们想要的是，每当选择框被更新时，过滤查询应该被清除。无论是单选按钮还是输入框，选择一个新的字段都应该重置过滤器查询，这确保了新的搜索可以开始。

这是通过移除选择框和`filter.field`变量之间的链接并创建我们自己的方法来处理更新来完成的。然后，当选择框改变时，我们触发该方法。该方法将清除`query`变量，并将`field`变量设置为选择框值。

删除选择框上的`v-model`属性，并添加一个新的`v-on:change`属性。我们将向其中传递一个方法名，该方法名将在每次更新选择框时触发。

`v-on`是一种新的 Vue 绑定，我们以前从未遇到过。它允许您将元素的动作绑定到 Vue 方法。例如，`v-on:click`是最常用的——它允许您将一个`click`函数绑定到元素上。我们将在本书的下一节中对此进行更多的讨论。

其中 v-bind 可以将`abbreviated`简化为一个冒号，`v-on`可以简化为一个`@`符号，允许您使用`@click=""`，例如:

```
      <select v-on:change="changeFilter($event)"     
       id="filterField">
        <option value="">Disable filters</option>
        <option value="isActive">Active user</option>
        <option value="name">Name</option>
        <option value="email">Email</option>
        <option value="balance">Balance</option>
        <option value="registered">Date 
         registered</option>
      </select>
```

该属性在每次更新时触发`changeFilter`方法，并向其传递变更的`$event`数据。这个默认的 Vue 事件对象包含了很多我们可以利用的信息，但是`target.value`数据才是我们想要的关键。

在 Vue 实例中创建一个新方法，该方法接受事件参数并更新`query`和`field`变量。需要清除`query`变量，所以将其设置为空字符串，而`field`变量可以设置为选择框的值:

```
      changeFilter(event) {
        this.filter.query = '';
        this.filter.field = event.target.value;
      }
```

现在查看您的应用程序应该可以清除过滤器查询，同时仍然可以按预期运行。



# 组合格式功能

我们的下一个优化将是在我们的 Vue 实例中组合`formatBalance`和`formatDate`方法。这将允许我们扩展我们的格式函数，而不用用几个具有相似功能的方法来膨胀代码。使用格式样式函数有两种方法——我们可以自动检测输入的格式，或者将所需的格式选项作为第二个选项传入。两者都有其优点和缺点，但我们将走过两者。



# 自动检测格式

变量类型的自动检测，当传递到一个函数中时，对于更干净的代码来说是非常好的。在您看来，您可以调用该函数并传递一个想要格式化的参数。例如:

```
      {{ format(person.balance) }}
```

该方法将包含一个`switch`语句，并根据`typeof`值格式化变量。一个`switch`语句可以计算一个表达式，然后根据输出执行不同的代码。`Switch`语句可以非常强大，因为它们允许构建子句——根据结果使用几个不同的代码。更多关于 MDN 上的`switch`声明可以阅读。

如果要比较同一个表达式，那么`Switch`语句是`if`语句的绝佳替代。对于一个代码块，您还可以有几种情况，甚至可以包括一个缺省值，如果前面的情况都不满足的话。作为一个使用中的例子，我们的格式方法可能看起来像:

```
      format(variable) {
        switch (typeof variable) {
          case 'string':
          // Formatting if the variable is a string
          break;
          case 'number':
          // Number formatting
          break;
          default:
          // Default formatting
          break;
        }
      }
```

需要注意的重要事情是`break;`行。这些完成了每个`switch`案例。如果省略了 break，代码将继续执行下面的情况——这有时是想要的效果。

自动检测变量类型和格式是简化代码的好方法。然而，对于我们的应用程序，这不是一个合适的解决方案，因为我们正在格式化日期，当输出`typeof`时会产生一个字符串，并且无法从我们可能希望格式化的其他字符串中识别出来。



# 传入第二个变量

上述自动检测的替代方法是将第二个变量传递给`format`函数。如果我们希望格式化其他字段，这为我们提供了更大的灵活性和可伸缩性。对于第二个变量，我们可以传入一个与我们的`switch`语句中预先选择的列表相匹配的固定字符串，也可以传入字段本身。视图中固定字符串方法的一个例子是:

```
      {{ format(person.balance, 'currency') }}
```

这将完美地工作，如果我们有几个不同的字段都需要像`balance`目前所做的那样格式化，这将非常好，但是在使用`balance`键和`currency`格式时似乎有一些轻微的重复。

作为一种折衷，我们将把`person`对象作为第一个参数传递，这样我们就可以访问所有的数据，而字段名作为第二个参数。然后，我们将使用它来确定所需的格式方法，并返回特定的数据。



# 创建方法

在您看来，用单一格式的函数替换`formatDate`和`formatBalance`函数，将`person`变量作为第一个参数，将带引号的字段作为第二个参数:

```
      <td v-bind:class="balanceClass(person)">
        {{ format(person, 'balance') }}
      </td>
      <td>
        {{ format(person, 'registered') }}
      </td>
```

在 Vue 实例中创建一个新的 format 方法，它接受两个参数:`person`和`key`。第一步，使用 person 对象和`key`变量检索字段:

```
      format(person, key) {
        let field = person[key],
            output = field.toString().trim();      
        return output;
      }
```

我们还在名为`output`的函数中创建了第二个变量——这将是函数结束时返回的内容，默认情况下设置为`field`。这确保了如果我们的格式化键与传入的键不匹配，将返回未动过的字段数据——但是，我们会将字段转换为字符串，并删除变量中的任何空白。现在运行应用程序将返回没有任何格式的字段。

添加一个`switch`语句，将表达式设置为`key`。在`switch`陈述中增加两种情况——一种是`balance`，另一种是`registered`。由于我们不希望我们的输入与某个案例不匹配时发生任何事情，所以我们不需要使用`default`语句:

```
      format(person, key) {
        let field = person[key],
            output = field.toString().trim();

        switch(key) {
 case 'balance':
 break;
 case 'registered':
 break;
 }
        return output;
      }
```

我们现在只需要将原始格式化函数中的代码复制到各个案例中:

```
      format(person, key) {
        let field = person[key],
            output = field.toString().trim();

        switch(key) {
          case 'balance':
            output = this.currency + field.toFixed(2);
            break;

          case 'registered':
           let registered = new Date(field);
 output = registered.toLocaleString('en-US');
          break;
        }
        return output;
      }
```

这种格式功能现在灵活多了。我们可以添加更多的`switch`案例来满足更多的字段(例如，处理`name`字段)，或者我们可以向现有代码添加新的案例。例如，如果我们的数据包含一个详细描述用户`deactivated`的账户日期的字段，我们可以很容易地以与注册时相同的格式显示它:

```
      case 'registered':
 case 'deactivated':
        let registered = new Date(field);
        output = registered.toLocaleString('en-US');
        break;
```



# 减少硬编码变量和属性的数量，并减少冗余

当查看 Vue JavaScript 时，很快就会发现，可以通过引入全局变量并在函数中设置更多局部变量来优化它，以使它更具可读性。我们也可以使用现有的功能来停止重复自己。

第一个优化是在我们的`filterRow()`方法中，我们检查`filter.field`是否是活动的。这也在我们用来显示和隐藏单选按钮的`isActiveFilterSelected`方法中重复。将`if`语句更新为使用该方法，代码如下:

```
      ...

    if(this.filter.field === 'isActive') {
    result = (typeof this.filter.query === 'boolean') ?       
    (this.filter.query === person.isActive) : true;
      } else {

      ...
```

前面的代码删除了`this.filter.field === 'isActive'`代码，并替换为`isActiveFilterSelected()`方法。它现在应该是这样的:

```
      ...

    if(this.isActiveFilterSelected()) {
    result = (typeof this.filter.query === 'boolean') ?     
     (this.filter.query === person.isActive) : true;
     } else {

      ...
```

当我们使用`filterRow`方法时，我们可以通过在方法开始时将`query`和`field`存储为变量来减少代码。`result`也不是合适的关键词，所以我们把它改成`visible`。首先，在开始时创建并存储我们的两个变量，并将`result`重命名为`visible`:

```
      filterRow(person) {
        let visible = true,
 field = this.filter.field,
 query = this.filter.query;      ...
```

例如，替换变量函数中所有实例，方法的第一部分如下所示:

```
      if(field) {
          if(this.isActiveFilterSelected()) {
            visible = (typeof query === 'boolean') ?   
            (query === person.isActive) : true;
          } else {

          query = String(query),
          field = person[field];
```

保存文件并在浏览器中打开应用程序，以确保您的优化没有破坏功能。

最后一个阶段是将这些方法重新排序，使之对您有意义。随意添加注释来区分不同的方法类型——例如，与 CSS 类或过滤相关的方法类型。我还移除了`activeStatus`方法，因为我们能够利用我们的`format`方法来*格式化*该字段的输出。优化后，JavaScript 代码看起来如下所示:

```
      const app = new Vue({
        el: '#app',
         data: {
          people: [...],
          currency: '$',
          filter: {
            field: '',
            query: ''
          }
        },
        methods: {
          isActiveFilterSelected() {
            return (this.filter.field === 'isActive');
          },
          /**
           * CSS Classes
           */
          activeClass(person) {
             return person.isActive ? 'active' : 
             'inactive';
          },
           balanceClass(person) {
            let balanceLevel = 'success';
            if(person.balance < 2000) {
              balanceLevel = 'error';
            } else if (person.balance < 3000) {
              balanceLevel = 'warning';
            }
                let increasing = false,
                balance = person.balance / 1000;
            if(Math.round(balance) == 
             Math.ceil(balance)) {
              increasing = 'increasing';
            }
            return [balanceLevel, increasing];
          },
          /**
           * Display
           */
          format(person, key) {
            let field = person[key],
            output = field.toString().trim();
            switch(key) {
              case 'balance':
                output = this.currency + 
              field.toFixed(2);
                break;
              case 'registered':
          let registered = new Date(field);
          output = registered.toLocaleString('en-US');
          break;  
        case 'isActive':
          output = (person.isActive) ? 'Active' : 
          'Inactive';
            }
        return output;
          },  
          /**
           * Filtering
           */
          changeFilter(event) {
            this.filter.query = '';
            this.filter.field = event.target.value;
          },
          filterRow(person) {
            let visible = true,
                field = this.filter.field,
                query = this.filter.query; 
            if(field) {  
              if(this.isActiveFilterSelected()) {
                visible = (typeof query === 'boolean') ?
               (query === person.isActive) : true;
              } else { 
                query = String(query),
                field = person[field];
                if(typeof field === 'number') {
                  query.replace(this.currency, '');  
                  try {
                    visible = eval(field + query);
                  } catch(e) {}  
                } else {  
                  field = field.toLowerCase();
                  visible = 
                  field.includes(query.toLowerCase());         
                }
              }
            }
            return visible;
          }
        }
      });
```



# 创建 Vue 组件

现在我们确信我们的代码更干净了，我们可以继续为我们的应用程序的各个部分制作 Vue 组件了。现在先把代码放在一边，打开一个新文档，同时开始处理组件。

Vue 组件非常强大，是任何 Vue 应用程序的绝佳补充。它们允许您制作可重用代码包，其中包含它们自己的数据、方法和计算值。

对于我们的应用程序，我们有机会创建两个组件:一个用于每个人，一个用于应用程序的过滤部分。我鼓励你尽可能地将你的应用分成几个部分——这有助于将你的代码分成相关的功能。

组件看起来像迷你 Vue 实例，因为每个组件都有自己的数据、方法和计算对象——以及一些组件特定的选项，我们将很快介绍这些选项。在创建一个包含不同页面和部分的应用程序时，组件也非常有用——这将在第 8 章、*介绍 Vue-Router 和加载基于 URL 的组件*中讨论。

注册组件后，您可以创建一个自定义 HTML 元素在视图中使用，例如:

```
      <my-component></my-component>
```

在命名组件时，可以使用 kebab-case(连字符)、PascalCase(无标点符号，但每个单词都大写)或 camelCase(类似于 Pascal 但第一个单词不大写)。Vue 组件不受 W3C web components/custom element 规则的限制，也不与 W3C web components/custom element 规则相关联，但是遵循使用 kebab-case 的约定是一个很好的实践。



# 创建和初始化组件

使用`Vue.component(tagName, options)`语法注册 Vue 组件。每个组件必须有一个关联的标记名。在初始化 Vue 实例之前，`Vue.component`注册**必须**发生。作为最低要求，每个组件都应该有一个`template`属性——表示当组件被使用时应该显示什么。模板必须总是有一个包装元素；这是为了用父容器替换自定义 HTML 标记。

例如，您不能将以下内容作为模板:

```
      <div>Hello</div><div>Goodbye</div>
```

如果您确实传递了这种格式的模板，Vue 将在浏览器的 JavaScript 控制台中抛出一个错误警告您。

使用简单的固定模板，自己创建一个 Vue 组件:

```
 Vue.component('my-component', {
 template: '<div>hello</div>'
 });

      const app = new Vue({
        el: '#app',

       // App options
      });
```

声明了这个组件后，它现在会给我们一个在视图中使用的`<my-component></my-component>` HTML 标签。

您还可以在 Vue 实例本身上指定组件。如果您在一个站点上有多个 Vue 实例，并且希望将一个组件包含到一个实例中，那么可以使用这种方法。为此，将组件创建为一个简单的对象，并在 Vue 实例的`components`对象中分配`tagName`:

```
      let Child = {
        template: '<div>hello</div>'
      }

      const app = new Vue({
        el: '#app',

        // App options

        components: {
          'my-component': Child
        }
      });
```

但是对于我们的应用程序，我们将坚持使用`Vue.component()`方法来初始化我们的组件。



# 使用您的组件

在您的视图中，添加您的自定义 HTML 元素组件:

```
      <div id="app">
        <my-component></my-component>
      </div>
```

在浏览器中查看这个应该会用一个`<div>`和一个 hello 消息替换掉`<my-component>` HTML 标签。

可能会有一些自定义 HTML 标签无法被解析和接受的情况——这些情况往往出现在`<table>`、`<ol>`、`<ul>`和`<select>`元素中。如果是这种情况，你可以在一个标准的 HTML 元素上使用`is=""`属性:

```
      <ol>
        <li is="my-component"></li>
      </ol>
```



# 使用组件数据和方法

由于 Vue 组件是您的 Vue 应用程序的自包含元素，它们每个都有自己的数据和功能。这有助于在同一页面上重用组件，因为每个组件实例的信息都是独立的。`methods`和`computed`函数的声明与您在 Vue 应用程序上的声明相同，但是，数据键应该是一个返回对象的函数。

The data object of a component must be a function. This is so that each component has its own self-contained data, rather than getting confused and sharing data between different instances of the same component. The function must still return an object as you would in your Vue app.

创建一个名为`balance`的新组件，向组件添加一个`data`函数和`computed`对象，并向`template`属性添加一个空的`<div>`:

```
      Vue.component('balance', {
        template: '<div></div>',
        data() {
          return {

          }
        },
        computed: {

        }
      });
```

接下来，用一个整数将一个键/值对添加到您的`cost`数据对象，并将变量添加到您的模板。将`<balance></balance>` 自定义 HTML 元素添加到您的视图中，您应该看到您的整数:

```
      Vue.component('balance', {
        template: '<div>{{ cost }}</div>',
        data() {
          return {
            cost: 1234
          }
        },
        computed: {

        }
      });
```

与第一章[、*Vue . js*中的 Vue 实例一样，向`computed`对象添加一个函数，该函数向整数追加一个货币符号，并确保有两位小数。不要忘记在数据函数中添加货币符号。](part0023.html#LTSU0-985bf4ae118d4f62b18ae64204cb251c)

更新模板以输出计算值，而不是直接成本:

```
      Vue.component('balance', {
        template: '<div>{{ formattedCost }}</div>',
        data() {
          return {
            cost: 1234,
            currency: '$'
          }
        },
        computed: {
          formattedCost() {
 return this.currency + this.cost.toFixed(2);
 }
        }
      });
```

这是一个组件的基本例子，然而，它受到组件本身的固定`cost`的限制。



# 将数据传递到您的组件 props

将天平作为一个组件是很好的，但如果天平是固定的，那就不太好了。当您添加了通过 HTML 属性传递参数和属性的能力时，组件才真正发挥了作用。在 Vue 世界里，这些被称为**道具**。道具可以是静态的，也可以是可变的。为了让组件获得这些属性，您需要使用`props`属性在组件上创建一个数组。

例如，如果我们想要制作一个`heading`组件:

```
      Vue.component('heading', {
        template: '<h1>{{ text }}</h1>',

        props: ['text']
      });
```

该组件将在视图中使用，如下所示:

```
      <heading text="Hello!"></heading>
```

使用 props，我们不需要在数据对象中定义`text`变量，因为在 props 数组中定义它会自动使它在模板中可用。props 数组还可以接受更多的选项，允许您定义期望的输入类型，它是必需的还是缺省值。

向 balance 组件添加一个 prop，这样我们可以将成本作为 HTML 属性传递。您的视图现在应该如下所示:

```
      <balance cost="1234"></balance> 
```

我们现在可以在 JavaScript 中将成本属性添加到组件中，并从我们的数据函数中删除固定值:

```
      template: '<div>{{ formattedCost }}</div>',
 props: ['cost'],
      data() {
        return {
          currency: '$'
        }
      },
```

然而，在我们的浏览器中运行它会在我们的 JavaScript 控制台中抛出一个错误。这是因为，从本质上讲，传入的属性被解释为字符串。我们可以用两种方式解决这个问题:我们可以在我们的`formatCost()`函数中将我们的属性转换成一个数字，或者，我们可以使用`v-bind:` HTML 属性告诉 Vue 接受输入。

如果您还记得，我们对`true`和`false`值的过滤器使用了这种技术——允许它们作为布尔值而不是字符串使用。在你的`cost` HTML 属性前添加`v-bind:`:

```
      <balance v-bind:cost="15234"></balance> 
```

我们可以做一个额外的步骤来确保 Vue 知道预期的输入类型，并通知代码的其他用户他们应该向组件传递什么。这可以在组件本身中完成，并且与格式一起，允许您指定默认值以及是否需要属性。

将你的`props`数组转换成一个对象，用`cost`作为键。如果您只是定义字段类型，那么您可以使用 Vue 简写来声明它，方法是将值设置为字段类型。这些可以是字符串、数字、布尔值、函数、对象、数组或符号。因为我们的成本属性应该是一个数字，所以添加它作为关键字:

```
      props: {
 cost: Number
 },
```

如果我们的组件呈现了`$0.00`，而不是在什么都没有定义时抛出错误，那就太好了。我们可以通过将默认值设置为`0`来做到这一点。为了定义一个默认值，我们需要将道具转换成一个对象本身——包含一个值为`Number`的 `type`键。然后我们可以定义另一个`default`键，并将值设置为`0` :

```
      props: {
        cost: {
          type: Number,
 default: 0
 }
      },
```

在浏览器中呈现组件应该显示传递到成本属性中的任何值——但是移除它将会呈现`$0.00`。

概括地说，我们的组件看起来像:

```
      Vue.component('balance', {
        template: '<div>{{ formattedCost }}</div>',

        props: {
          cost: {
            type: Number,
            default: 0
          }
        },

        data() {
          return {
            currency: '$'
          }
        },

        computed: {
          formattedCost() {
            return this.currency +       
            this.cost.toFixed(2);
          }
        }
      });
```

当我们制作清单应用程序的`person`组件时，我们应该能够扩展这个例子。



# 将数据传递到组件插槽

有时，您可能需要将未存储在属性中的 HTML 块或您希望在出现在组件中之前格式化的 HTML 块传递给组件。您可以在组件中使用插槽，而不是尝试在计算变量或类似变量中进行预格式化。

插槽就像占位符，允许您在组件的开始和结束标记之间放置内容，并确定它们将显示在哪里。

一个完美的例子就是模态窗口。这些通常有几个标签，如果你想在你的应用程序中多次使用它的话，它们通常包含许多需要复制和粘贴的 HTML。相反，您可以创建一个`modal-window`组件，并用一个 slot 传递您的 HTML。

创建一个名为`modal-window`的新组件。它接受一个属性`visible`，这个属性接受一个布尔值，默认为`false`。对于模板，我们将使用来自*Bootstrap model*的 HTML 作为一个很好的例子，来说明一个使用插槽的组件是如何简化你的应用程序的。为了确保组件的样式，请确保在文档中包含引导程序*资产文件*:

```
      Vue.component('modal-window', {
        template: `<div class="modal fade">
          <div class="modal-dialog" role="document">
            <div class="modal-content">
              <div class="modal-header">
               <button type="button" class="close" 
               data-dismiss="modal" aria-label="Close">
               <span aria-hidden="true">&times;</span>
              </button>
             </div>
          <div class="modal-body">
          </div>
           <div class="modal-footer">
            <button type="button" class="btn btn-  
             primary">Save changes</button>
            <button type="button" class="btn btn-      
             secondary" data-dismiss="modal">Close
            </button>
            </div>
          </div>
         </div>
      </div>`,

      props: {
        visible: {
          type: Boolean,
          default: false
        }
       }
    });
```

我们将使用 visible prop 来确定模态窗口是否打开。向接受`visible`变量的外部容器添加一个`v-show`属性:

```
      Vue.component('modal-window', {
          template: `<div class="modal fade" v-
            show="visible">
          ...
        </div>`,

        props: {
          visible: {
            type: Boolean,
            default: false
          }
        }
      });
```

将您的`modal-window`组件添加到应用程序中，暂时将`visible`指定为`true`,这样我们就可以了解并看到发生了什么:

```
      <modal-window :visible="true"></modal-window>
```

我们现在需要将一些数据传递给我们的模态盒。在两个标签之间添加一个标题和一些段落:

```
      <modal-window :visible="true">
        <h1>Modal Title</h1>
 <p>Lorem ipsum dolor sit amet, consectetur                
         adipiscing elit. Suspendisse ut rutrum ante, a          
         ultrices felis. Quisque sodales diam non mi            
         blandit dapibus. </p>
 <p>Lorem ipsum dolor sit amet, consectetur             
          adipiscing elit. Suspendisse ut rutrum ante, a             
          ultrices felis. Quisque sodales diam non mi             
          blandit dapibus. </p>
       </modal-window>
```

在浏览器中按下 refresh 不会做任何事情，因为我们需要告诉组件如何处理数据。在你的模板中，在你希望内容出现的地方添加一个`<slot></slot>` HTML 标签。用`modal-body`类将它添加到`div`:

```
      Vue.component('modal-window', {
        template: `<div class="modal fade" v-      
        show="visible">
          <div class="modal-dialog" role="document">
            <div class="modal-content">
              <div class="modal-header">
          <button type="button" class="close" data-              
              dismiss="modal" aria-label="Close">
               <span aria-hidden="true">&times;</span>
             </button>
              </div>
              <div class="modal-body">
                <slot></slot>
              </div>
              <div class="modal-footer">
              <button type="button" class="btn btn-  
             primary">Save changes</button>
             <button type="button" class="btn btn-                   
               secondary" data-
            dismiss="modal">Close</button>
           </div>
           </div>
        </div>
        </div>`,

         props: {
          visible: {
            type: Boolean,
            default: false
          }
        }
      });
```

查看您的应用程序将会显示您在模式窗口中传递的内容。有了这个新组件，应用程序看起来更整洁了。

查看 Bootstrap HTML，我们可以看到有足够的空间放置页眉、正文和页脚。我们可以用命名的槽来标识这些部分。这允许我们将特定的内容传递到组件的特定区域。

在模式窗口的页眉和页脚创建两个新的`<slot>`标签。为这些新属性赋予一个名称属性，但保留现有属性为空:

```
      template: `<div class="modal fade" v-              
      show="visible">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <slot name="header"></slot>
              <button type="button" class="close" data-
               dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span>
             </button>
          </div>
           <div class="modal-body">
            <slot></slot>
          </div>
          <div class="modal-footer">
            <slot name="footer"></slot>
            <button type="button" class="btn btn-  
            primary">Save changes</button><button type="button" class="btn btn-
           secondary" data-
           dismiss="modal">Close</button>
           </div>
        </div>
       </div>
     </div>`,
```

在我们的应用程序中，我们现在可以通过在 HTML 中指定一个`slot`属性来指定什么内容去哪里。这可以放在一个特定的标签上，也可以放在几个标签周围的容器中。任何没有`slot`属性的 HTML 也将默认为您的未命名槽:

```
      <modal-window :visible="true">
        <h1 slot="header">Modal Title</h1>

        <p>Lorem ipsum dolor sit amet, consectetur             
        adipiscing elit. Suspendisse ut rutrum ante, a 
        ultrices felis. Quisque sodales diam non mi 
         blandit dapibus. </p>

        <p slot="footer">Lorem ipsum dolor sit amet,            
         consectetur adipiscing elit. Suspendisse ut 
         rutrum ante, a ultrices felis. Quisque sodales 
           diam non mi blandit dapibus. </p>
      </modal-window>
```

我们现在可以指定内容并将其定向到特定的位置。

您可以对插槽做的最后一件事是指定一个默认值。例如，您可能希望大部分时间都在页脚显示按钮，但是希望能够在需要时替换它们。使用`<slot>`，除非在应用程序中指定组件时被覆盖，否则将显示标签之间的任何内容。

创建一个标题为`buttons`的新槽，并将按钮放在里面的页脚。尝试用其他内容替换它们。

模板变成:

```
      template: `<div class="modal fade" v-
      show="visible">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <slot name="header"></slot>
              <button type="button" class="close" data-
              dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              <slot></slot>
            </div>
            <div class="modal-footer">
              <slot name="footer"></slot>
              <slot name="buttons">
                <button type="button" class="btn btn-
                 primary">Save changes</button>
                <button type="button" class="btn btn-
                 secondary" data-
                 dismiss="modal">Close</button>
              </slot>
            </div>
          </div>
        </div>
      </div>`,
```

和 HTML:

```

     <modal-window :visible="true">
     <h1 slot="header">Modal Title</h1>
      <p>Lorem ipsum dolor sit amet, consectetur 
      adipiscing elit. Suspendisse ut rutrum ante, a 
      ultrices felis. Quisque sodales diam non mi blandit 
      dapibus. </p>

        <p slot="footer">Lorem ipsum dolor sit amet, 
       consectetur adipiscing elit. Suspendisse ut rutrum 
       ante, a ultrices felis. Quisque sodales diam non mi 
       blandit dapibus. </p>

        <div slot="buttons">
 <button type="button" class="btn btn-      
           primary">Ok</button> </div>
       </modal-window>
```

虽然我们不会在我们的人员列表应用程序中使用插槽，但了解 Vue 组件的功能还是有好处的。如果你希望像这样使用一个模态框，你可以设置一个默认为假的变量的可见性。然后，您可以添加一个带有 click 方法的按钮，将变量从`false`更改为`true`——显示模式框。



# 创建可重复的组件

组件的美妙之处在于能够在同一个视图中多次使用它们。这使您能够拥有一个用于数据布局的“真实来源”。我们将为人员列表创建一个可重复的组件，并为过滤部分创建一个单独的组件。

打开您在前几章中创建的人员列表代码，并创建一个名为`team-member`的新组件。不要忘记在初始化你的 Vue 应用之前定义组件。向组件添加一个`prop`以允许 person 对象被传入。出于验证目的，仅指定 it 可以是`Object`:

```
      Vue.component('team-member', {
        props: {
          person: Object
        }
      });
```

我们现在需要将我们的模板集成到组件中，组件是我们视图中的`tr`内的所有东西。

组件中的模板变量只接受不带新行的普通字符串，因此我们需要执行以下操作之一:

*   内嵌我们的 HTML 模板——非常适合小模板，但是在这种情况下会牺牲可读性
*   添加带有`+`字符串连接的新行——对于一两行来说很好，但是会使我们的 JavaScript 膨胀
*   创建一个模板块——Vue 为我们提供了使用外部模板的选项，这些模板是使用 `text/x-template`语法和 ID 在视图中定义的

由于我们的模板相当大，我们将选择第三个选项，在视图的末尾声明模板。

在您的 HTML 中，在您的应用程序之外，创建一个新的脚本块，并添加一个`type`和`ID`属性:

```
      <script type="text/x-template" id="team-member-            
       template">
      </script>
```

然后，我们可以将我们的人员模板移动到该块中，并删除`v-for`属性——我们仍将在应用程序本身中使用该属性:

```
      <script type="text/x-template" id="team-member-
      template">
        <tr v-show="filterRow(person)">
 <td>
 {{ person.name }}
 </td>
 <td>
 <a v-bind:href="'mailto:' + person.email">{{                
             person.email }}</a>
 </td>
 <td v-bind:class="balanceClass(person)">
 {{ format(person, 'balance') }}
 </td>
 <td>
 {{ format(person, 'registered') }}
 </td>
 <td v-bind:class="activeClass(person)">
 {{ format(person, 'isActive') }}
 </td>
 </tr>
      </script>
```

我们现在需要更新视图来使用`team-member`组件，而不是固定代码。为了使我们的视图更清晰、更容易理解，我们将利用前面提到的`<template>` HTML 属性。创建一个`<template>`标签，并添加之前的`v-for`循环。为了避免混淆，更新循环，使用`individual`作为每个人的变量。它们可以是相同的，但是如果变量、组件和属性有不同的名称，会使代码更容易阅读。将`v-for`更新为`v-for="individual in people"`:

```
      <table>
       <template v-for="individual in people">
       </template>
      </table>
```

在视图的`template`标签中，添加一个新的`team-member`组件实例，将`individual`变量传递给`person`属性。别忘了给 person prop 加上`v-bind:`，否则，组件会把它解释为一个固定的字符串，带有个人的值:

```
      <table>
        <template v-for="individual in people">
          <team-member v-bind:person="individual"></team-           
            member>
        </template>
      </table>
```

我们现在需要更新组件，以使用我们使用`template`属性和脚本块的 ID 作为值声明的模板:

```
      Vue.component('team-member', {
        template: '#team-member-template',
        props: {
          person: Object
        }
      });
```

在浏览器中查看应用程序会在 JavaScript 控制台中产生几个错误。这是因为我们引用了几个不再可用的方法——因为它们在父 Vue 实例上，而不是在组件上。如果您想要验证您的组件是否在工作，请将代码更改为只输出人员的姓名，然后按 refresh:

```
      <script type="text/x-template" id="team-member-             
        template">
        <tr v-show="filterRow()">
          <td>
            {{ person.name }}
          </td>
        </tr>
      </script>
```



# 创建组件方法和计算函数

我们现在需要在子组件上创建我们在 Vue 实例上创建的方法，这样它们就可以使用了。我们可以做的一件事是将父方法剪切并粘贴到子方法中，希望它们能够工作；然而，这些方法依赖于父属性(如过滤数据),我们也有机会利用`computed`属性，这些属性缓存数据并可以加快您的应用程序。

现在，从`tr`元素中删除`v-show`属性——因为这涉及到过滤，一旦我们正确显示了行，就会涉及到这个问题。我们将逐步解决这些错误，一次解决一个，以帮助您理解使用 Vue 解决问题。



# CSS 类函数

在浏览器中查看应用程序时，我们遇到的第一个错误是:

Property or method "balanceClass" is not defined

第一个错误是关于我们使用的`balanceClass`和`activeClass`函数。这两个函数都基于个人数据添加 CSS 类，一旦组件被呈现，这些数据就不会改变。

因此，我们能够使用 Vue 中的缓存。将这些方法移到组件中，但是将它们放在一个新的`computed`对象中，而不是放在`methods`对象中。

有了组件，每次调用时都会创建一个新的实例，所以我们可以依赖通过`prop`传入的`person`对象，而不再需要将`person`传入函数。从函数和视图中移除参数——同时将函数中对`person`和*的引用更新为`this.person`,以引用存储在组件中的对象:*

```
 computed: {
        /**
         * CSS Classes
         */
        activeClass() {
          return this.person.isActive ? 'active' : 
      'inactive';
        },

        balanceClass() {
          let balanceLevel = 'success';

          if(this.person.balance < 2000) {
            balanceLevel = 'error';
          } else if (this.person.balance < 3000) {
            balanceLevel = 'warning';
          }

          let increasing = false,
              balance = this.person.balance / 1000;

          if(Math.round(balance) == Math.ceil(balance)) {
            increasing = 'increasing';
          }

          return [balanceLevel, increasing];
        }
 },
```

我们的组件模板中使用这个函数的部分现在应该看起来像这样:

```
      <td v-bind:class="balanceClass">
    {{ format(person, 'balance') }}
      </td>
```



# 格式化值函数

当谈到将`format()`函数移动到组件来格式化我们的数据时，我们面临两种选择。我们可以移动它，把它放在`methods`对象中，或者我们可以利用 Vue 缓存和约定，为每个值创建一个`computed`函数。

我们构建这个应用程序是为了可伸缩性，所以为每个值创建计算函数是明智的——它也有利于整理我们的模板。在计算对象中创建三个名为`balance`、`dateRegistered`和`status`的函数。将`format`函数的相应部分复制到每个函数中，再次更新`person`到`this.person`的引用。

在我们使用函数参数检索字段的地方，您现在可以在每个函数中修改值。您还需要为 balance 函数添加一个带有货币符号的数据对象——将其添加在`props`之后:

```
      data() {
        return {
          currency: '$'
        }
      },
```

由于`team-member`组件是唯一使用货币符号的地方，我们可以将其从 Vue 应用程序本身中移除。我们还可以从父 Vue 实例中删除 format 函数。

总的来说，我们的 Vue `team-member`组件应该是这样的:

```
      Vue.component('team-member', {
        template: '#team-member-template',
        props: {
          person: Object 
       },
        data() {
          return {
            currency: '$'
          }
        },
        computed: {
          /**
           * CSS Classes
           */
          activeClass() {
            return this.person.isActive ? 'active' : 
            'inactive';
          },
          balanceClass() {
            let balanceLevel = 'success';   
            if(this.person.balance < 2000) {
              balanceLevel = 'error';
            } else if (this.person.balance < 3000) {
              balanceLevel = 'warning';
            }
          let increasing = false,
                balance = this.person.balance / 1000; 
            if(Math.round(balance) == Math.ceil(balance))                           
            {
              increasing = 'increasing';
            }
            return [balanceLevel, increasing];
          }, 
          /**
           * Fields
           */
          balance() {
            return this.currency +       
            this.person.balance.toFixed(2);
          },
          dateRegistered() {
            let registered = new 
            Date(this.person.registered);
            return registered.toLocaleString('en-US');
          },
          status() {
            return (this.person.isActive) ? 'Active' : 
            'Inactive';
          }
        }
      });
```

与实际情况相比，我们的`team-member-template`应该看起来相当简单:

```
      <script type="text/x-template" id="team-member-
      template">
        <tr v-show="filterRow()">
          <td>
            {{ person.name }}
          </td>
          <td>
            <a v-bind:href="'mailto:' + person.email">{{ 
            person.email }}</a>
          </td>
          <td v-bind:class="balanceClass">
            {{ balance }}
          </td>
          <td>
            {{ dateRegistered }}
          </td>
          <td v-bind:class="activeClass">
            {{ status }}
          </td>
        </tr>
      </script>
```

最后，我们的 Vue 实例应该看起来小得多:

```
      const app = new Vue({
        el: '#app',
        data: {
          people: [...],
          filter: {
            field: '',
            query: ''
          }
        },
        methods: {
          isActiveFilterSelected() {
            return (this.filter.field === 'isActive');
          },   
          /**
           * Filtering
           */
          filterRow(person) {
            let visible = true,
                field = this.filter.field,
                query = this.filter.query;  
            if(field) {   
              if(this.isActiveFilterSelected()) {
                visible = (typeof query === 'boolean') ? 
                  (query === person.isActive) : true;
              } else {
                query = String(query),
                field = person[field]; 
          if(typeof field === 'number') {
            query.replace(this.currency, '');
                  try {
                    visible = eval(field + query);
                  } catch(e) {}   
                } else {
                  field = field.toLowerCase();
                  visible = 
                  field.includes(query.toLowerCase())  
                }
              }
            }
            return visible;
          }
          changeFilter(event) {
            this.filter.query = '';
            this.filter.field = event.target.value;
          }
        }
      });
```

在浏览器中查看该应用程序，我们应该看到我们的人员列表，表单元格中添加了正确的类，字段中添加了格式。



# 使用道具使过滤再次工作

将`v-show="filterRow()"`属性重新添加到模板中包含`tr`的元素中。因为我们的组件在每个实例上都缓存了 person，所以我们不再需要将 person 对象传递给方法。刷新页面会在 JavaScript 控制台中出现一个新错误:

```
Property or method "filterRow" is not defined on the instance but referenced during render
```

这个错误是因为我们的组件有`v-show`属性，根据我们的过滤和属性显示和隐藏，但没有相应的`filterRow`函数。因为我们不把它用于其他任何事情，我们可以把方法从 Vue 实例移到组件，把它添加到`methods`组件。删除 person 参数并更新方法以使用`this.person`:

```
      filterRow() {
        let visible = true,
            field = this.filter.field,
            query = this.filter.query;
            if(field) {
            if(this.isActiveFilterSelected()) {
            visible = (typeof query === 'boolean') ?                 
           (query === this.person.isActive) : true;
            } else {

            query = String(query),
            field = this.person[field];

            if(typeof field === 'number') {
              query.replace(this.currency, '');
              try {
                visible = eval(field + query);
              } catch(e) {}
              } else {

              field = field.toLowerCase();
              visible = 
            field.includes(query.toLowerCase());
            }
          }
        }
        return visible;
      }
```

控制台中的下一个错误是:

```
Cannot read property 'field' of undefined
```

过滤不起作用的原因是`filterRow`方法正在组件上寻找`this.filter.field`和`this.filter.query`，而不是它所属的父 Vue 实例。

As a quick fix, you can use `this.$parent` to reference data on the parent element—however, this is not recommended and should only be used in extreme circumstances or to quickly pass the data through.

为了将数据传递给组件，我们将使用另一个道具——类似于我们将人传递给组件的方式。幸运的是，我们已经对过滤数据进行了分组，所以我们能够传递一个对象，而不是单独的属性`query`或`field`。在你的组件上创建一个名为`filter`的新道具，并确保你只允许一个`Object`通过:

```
      props: {
        person: Object,
        filter: Object
      },
```

然后，我们可以将道具添加到`team-member`组件，允许我们传递数据:

```
      <table>
        <template v-for="individual in people">
          <team-member v-bind:person="individual" v-               
           bind:filter="filter"></team-member>
        </template>
      </table>
```

为了让我们的过滤工作，我们需要再传入一个属性——`isActiveFilterSelected()`函数。创建另一个名为`statusFilter`的道具，只允许一个`Boolean`作为值(因为这是该函数的等价值)，并传递该函数。更新`filterRow`方法以使用这个新值。我们的组件现在看起来像这样:

```
      Vue.component('team-member', {
        template: '#team-member-template',
        props: {
          person: Object,
          filter: Object,
          statusFilter: Boolean
        },
        data() {
          return {
            currency: '$'
          }
        },
        computed: {
          /**
           * CSS Classes
           */
          activeClass() {
            return this.person.isActive ? 'active' : 
            'inactive';
            },
            balanceClass() {
            let balanceLevel = 'success';

         if(this.person.balance < 2000) {
           balanceLevel = 'error';
          } else if (this.person.balance < 3000) {
            balanceLevel = 'warning';
          }
          let increasing = false,
            balance = this.person.balance / 1000;
           if(Math.round(balance) == Math.ceil(balance)) {
             increasing = 'increasing';
          }
          return [balanceLevel, increasing];
        },
       /**
       * Fields
         */
       balance() {
       return this.currency +    
       this.person.balance.toFixed(2);
       },
      dateRegistered() {
       let registered = new Date(this.registered); 
        return registered.toLocaleString('en-US');
        },
        status() {
           return output = (this.person.isActive) ?    
          'Active' : 'Inactive';
         }
       },
       methods: {
        filterRow() {
         let visible = true,
            field = this.filter.field,
            query = this.filter.query;

         if(field) {  
           if(this.statusFilter) {
             visible = (typeof query === 'boolean') ? 
            (query === this.person.isActive) : true;
           } else {
             query = String(query),
            field = this.person[field];  
              if(typeof field === 'number') {
                query.replace(this.currency, '');  
                 try {
                 visible = eval(field + query);
                } catch(e) {
            } 
           } else {   
            field = field.toLowerCase();
            visible = field.includes(query.toLowerCase());
             }
            }
           }
           return visible;
        }
       }
     });
```

带有额外道具的视图中的组件现在看起来如下。请注意，当用作 HTML 属性时，驼色大小写属性变成了蛇形大小写(连字符):

```
      <template v-for="individual in people">
          <team-member v-bind:person="individual" v-               bind:filter="filter" v-bind:status-      
            filter="isActiveFilterSelected()"></team-
            member>
       </template>
```



# 使过滤器成为一个组件

我们现在需要使过滤部分成为它自己的组件。这在这个场景中并不是绝对必要的，但是这是一个很好的实践，并且给了我们更多的挑战。

我们在使过滤成为组件时面临的问题是在过滤组件和`team-member`组件之间传输过滤数据的挑战。Vue 通过自定义事件解决了这个问题。这些允许您将数据从子组件传递(或“发出”)到父组件或其他组件。

我们将创建一个过滤组件，在过滤变更时，将数据传递回父 Vue 实例。这些数据已经被传递给`team-member`组件进行过滤。



# 创建组件

与`team-member`组件一样，在 JavaScript 中声明一个新的`Vue.component()`，引用一个模板 ID`#filtering-template`。在您的视图中创建一个新的`<script>`模板块，并赋予它相同的 ID。用一个`<filtering>`定制 HTML 模板替换视图中的过滤表单，并将表单放入您的`filtering-template`脚本块中。

您的视图应该如下所示:

```
      <div id="app">
       <filtering></filtering>
       <table>
         <template v-for="individual in people">
           <team-member v-bind:person="individual" v-
            bind:filter="filter" v-
            bind:statusfilter="isActiveFilterSelected()">           </team-member>
         </template>
       </table>
      </div>

 <script type="text/x-template" id="filtering-
      template">
        <form>
          <label for="fiterField">
            Field:
            <select v-on:change="changeFilter($event)"                 id="filterField">
           <option value="">Disable filters</option>
           <option value="isActive">Active user</option>
           <option value="name">Name</option>
           <option value="email">Email</option>
           <option value="balance">Balance</option>
           <option value="registered">Date      
            registered</option>
           </select>
         </label>
        <label for="filterQuery" v-show="this.filter.field 
         && !isActiveFilterSelected()">
            Query:
            <input type="text" id="filterQuery" v-
            model="filter.query">
          </label>
          <span v-show="isActiveFilterSelected()">
            Active:
         <label for="userStateActive">
            Yes:
             <input type="radio" v-bind:value="true"       id="userStateActive" v-model="filter.query">
          </label>
            <label for="userStateInactive">
            No:
        <input type="radio" v-bind:value="false" 
        id="userStateInactive" v-model="filter.query">
         </label>
       </span>
      </form>
 </script>
      <script type="text/x-template" id="team-member-
       template">
       // Team member template
    </script>
```

您的 JavaScript 中应该包含以下内容:

```
      Vue.component('filtering', {
        template: '#filtering-template'
      });
```



# 解决 JavaScript 错误

与`team-member`组件一样，您将在 JavaScript 控制台中遇到一些错误。这些问题可以通过从父实例中复制`filter`数据对象以及`changeFilter`和`isActiveFilterSelected`方法来解决。我们现在将它们保留在组件和父实例中，但是稍后我们将删除重复的内容:

```
      Vue.component('filtering', {
        template: '#filtering-template',

        data() {
 return {
 filter: {
 field: '',
 query: ''
 }
 }
 },

 methods: {
 isActiveFilterSelected() {
 return (this.filter.field === 'isActive');
 },

 changeFilter(event) {
 this.filter.query = '';
 this.filter.field = event.target.value;
 }
 }
      });
```

运行该应用程序将显示过滤器和人员列表，但过滤器不会更新人员列表，因为他们还没有沟通。



# 使用自定义事件更改过滤器字段

使用定制事件，您可以使用`$on`和`$emit`函数将数据传递回父实例。对于这个应用程序，我们将在父 Vue 实例上存储过滤数据，并从组件中更新它。然后,`team-member`组件可以从 Vue 实例中读取数据并进行相应的过滤。

第一步是利用父 Vue 实例上的过滤器对象。从组件中移除`data`对象，并通过一个道具传入父对象——就像我们对`team-member`组件所做的一样:

```
      <filtering v-bind:filter="filter"></filtering>
```

我们现在要修改`changeFilter`函数来发出事件数据给父实例，这样它就可以更新`filter`对象。

从`filtering`组件中移除现有的`changeFilter`方法，并创建一个名为`change-filter-field`的新方法。在这个方法中，我们只需要在下拉菜单中选择`$emit`字段的名称。`$emit`函数有两个参数:一个键和值。发出一个`change-filter-field`键，并将`event.target.value`作为数据传递。当使用包含多个单词的变量时(例如，`changeFilterField`，确保事件名称(`$emit`函数的第一个参数)和 HTML 属性用连字符连接:

```
      changeFilterField(event) {
        this.$emit('change-filter-field', 
      event.target.value);
      }
```

为了将数据传递给父 Vue 实例上的 changeFilter 方法，我们需要向我们的`<filtering>`元素添加一个新的 prop。这使用了`v-on`并绑定到自定义事件名称。然后，它将父方法名作为属性值。将属性添加到元素中:

```
      <filtering v-bind:filter="filter" v-on:change-filter-field="changeFilter"></filtering>
```

这个属性告诉 Vue 在发出一个`change-filter-field`事件时触发`changeFilter`方法。然后，我们可以调整我们的方法，接受参数作为值:

```
      changeFilter(field) {
        this.filter.query = '';
        this.filter.field = field;
      }
```

这将清除过滤器并更新字段值，然后通过 props 传递给我们的组件。



# 更新过滤器查询

为了发出查询字段，我们将使用一个我们以前没有使用过的新的 Vue 键，称为`watch`。`watch`函数跟踪数据属性，并可以基于输出运行方法。它能够做的另一件事是发出事件。我们的文本字段和单选按钮都设置为更新 field.query 变量，我们将在此基础上创建一个新的`watch`函数。

在组件上的方法之后创建一个新的`watch`对象:

```
      watch: {
        'filter.query': function() {
        }
      }
```

关键是你希望观察的变量。因为我们的代码包含一个点，所以需要用引号括起来。在这个函数中，创建一个新的`change-filter-query`的`$emit`事件，它输出`filter.query`的值:

```
     watch: {
         'filter.query': function() {
         this.$emit('change-filter-query', 
         this.filter.query)
         }
       }
```

我们现在需要将这个方法和定制事件绑定到视图中的组件，以便它能够将数据传递给父实例。将属性的值设置为`changeQuery`—我们将创建一个方法来处理这个问题:

```
      <filtering v-bind:filter="filter" v-on:change-      
      filter-field="changeFilter" v-on:change-filter-          
      query="changeQuery"></filtering>
```

在父 Vue 实例上，创建一个名为`changeQuery`的新方法，该方法只根据输入更新`filter.query`值:

```
     changeQuery(query) {
       this.filter.query = query;
     }
```

我们的过滤又开始工作了。更新选择框和输入框(或单选按钮)将会更新我们的人员列表。我们的 Vue 实例要小得多，我们的模板和方法包含在单独的组件中。

最后一步是避免重复使用`isActiveFilterSelected()`方法，因为这在`team-member`组件上只使用一次，而在`filtering`组件上使用多次。从父 Vue 实例中移除该方法，从`team-member` HTML 元素中移除 prop，并用传递的函数内容替换`team-member`组件中`filterRow`方法中的`statusFilter`变量。

最终的 JavaScript 现在看起来像这样:

```
      Vue.component('team-member', {
        template: '#team-member-template',
        props: {
          person: Object,
          filter: Object
        },
        data() {
          return {
            currency: '$'
          }
        },
        computed: {
          /**
           * CSS Classes
           */
           activeClass() {
            return this.person.isActive ? 'active' : 'inactive';
          },
          balanceClass() {
            let balanceLevel = 'success';    
            if(this.person.balance < 2000) {
              balanceLevel = 'error';
            } else if (this.person.balance < 3000) {
              balanceLevel = 'warning';
            }
           let increasing = false,
            balance = this.person.balance / 1000;      
            if(Math.round(balance) == Math.ceil(balance))             {
             increasing = 'increasing';
            } 
            return [balanceLevel, increasing];
          },
          /**
           * Fields
           */
          balance() {
            return this.currency +       
          this.person.balance.toFixed(2);
          },
          dateRegistered() {
            let registered = new Date(this.registered);  
            return registered.toLocaleString('en-US');
          },
          status() {
            return output = (this.person.isActive) ? 
           'Active' : 'Inactive';
          }
        },
          methods: {
          filterRow() {
            let visible = true,
            field = this.filter.field,
            query = this.filter.query;         
            if(field) {      
              if(this.filter.field === 'isActive') {
              visible = (typeof query === 'boolean') ? 
             (query === this.person.isActive) : true;
              } else {   
                query = String(query),
                field = this.person[field]; 
                if(typeof field === 'number') {
                  query.replace(this.currency, '');
               try {
              visible = eval(field + query);
            } catch(e) {}

          } else {

            field = field.toLowerCase();
            visible = field.includes(query.toLowerCase());  
              }
           }
          }
            return visible;
          }
          }
         });

     Vue.component('filtering', {
     template: '#filtering-template',
       props: {
       filter: Object
     },
       methods: {
       isActiveFilterSelected() {
        return (this.filter.field === 'isActive');
       },     
        changeFilterField(event) {
        this.filedField = '';
       this.$emit('change-filter-field',                     
        event.target.value);
          },
        },
        watch: {
    'filter.query': function() {
      this.$emit('change-filter-query', this.filter.query)
          }
        }
      });

      const app = new Vue({
        el: '#app',

        data: {
          people: [...],
          filter: {
            field: '',
            query: ''
          }
        },
        methods: { 
          changeFilter(field) {
            this.filter.query = '';
            this.filter.field = field;
          },
          changeQuery(query) {
            this.filter.query = query;
          }
        }
      });
```

现在的观点是:

```
     <div id="app">
        <filtering v-bind:filter="filter" v-on:change-
         filter-field="changeFilter" v-on:change-filter-
          query="changeQuery"></filtering>
       <table>
         <template v-for="individual in people">
          <team-member v-bind:person="individual" v-  
          bind:filter="filter"></team-member>
         </template>
        </table>
     </div>
    <script type="text/x-template" id="filtering-
     template">
       <form>
      <label for="fiterField">
       Field:
      <select v-on:change="changeFilterField($event)" 
         id="filterField">
        <option value="">Disable filters</option>
        <option value="isActive">Active user</option>
        <option value="name">Name</option>
        <option value="email">Email</option>
        <option value="balance">Balance</option>
        <option value="registered">Date     
          registered</option>
         </select>
          </label>
         <label for="filterQuery" v-
         show="this.filter.field && 
          !isActiveFilterSelected()">
         Query:
        <input type="text" id="filterQuery" v-    
         model="filter.query">
          </label>

          <span v-show="isActiveFilterSelected()">
           Active:

            <label for="userStateActive">
              Yes:
            <input type="radio" v-bind:value="true"   
          id="userStateActive" v-model="filter.query">
           </label>
          <label for="userStateInactive">
           No:
            <input type="radio" v-bind:value="false"                 id="userStateInactive" v-model="filter.query">
            </label>
          </span>
        </form>
      </script>
      <script type="text/x-template" id="team-member-
      template">
        <tr v-show="filterRow()">
          <td>
            {{ person.name }}
          </td>
          <td>
            <a v-bind:href="'mailto:' + person.email">{{                person.email }}</a>
          </td>
          <td v-bind:class="balanceClass">
            {{ balance }}
          </td>
          <td>
            {{ dateRegistered }}
          </td>
          <td v-bind:class="activeClass">
            {{ status }}
          </td>
        </tr>
      </script>
```



# 摘要

在最后三章中，您已经学习了如何初始化一个新的 Vue 实例，computed、method 和 data 对象背后的含义是什么，以及如何从一个对象中列出数据并操纵它正确显示。您还了解了如何制作组件，以及保持代码整洁和优化有什么好处。

在本书的下一部分，我们将介绍 Vuex，它可以帮助我们更好地存储和操作存储的数据。