

# 建立电子商务商店-浏览产品

在[第 9 章](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c)、*使用 Vue-Router 动态路由加载数据*中，我们将产品数据加载到 Vuex 商店中，并创建了一个产品详情页面，用户可以在其中查看产品及其变体。当查看产品详细信息页面时，用户可以从下拉列表中更改变化，价格和其他详细信息将会更新。

在本章中，我们将:

*   创建包含特定产品的主页列表页面
*   使用可重用组件创建类别页面
*   创建订购机制
*   动态创建过滤器，并允许用户过滤产品



# 列出产品

在我们创建任何过滤、管理列表、订购组件和功能之前，我们需要创建一个基本的产品列表，首先显示所有产品，然后我们可以创建一个分页组件，然后我们可以在整个应用程序中重用它。



# 添加新路线

让我们给我们的`routes`数组添加一条新的路线。现在，我们将致力于`HomePage`组件，它将拥有`/`路线。确保将它添加到`routes`数组的顶部，这样它就不会被任何其他组件覆盖:

```
const router = new VueRouter({
  routes: [
 {
 path: '/',
 name: 'Home',
 component: HomePage
 },
    {
      path: '/product/:slug', 
      component: ProductPage
    },

    {
      path: '/404', 
      alias: '*',
      component: PageNotFound
    }
  ]
});
```

在`HomePage`组件中，创建一个新的`computed`属性，并收集来自`store`的所有产品。在模板中显示任何内容之前，请确保产品已加载。用以下代码填充`HomePage`组件:

```
const HomePage = {
  name: 'HomePage',

  template: `<div v-if="products"></div>`,

  computed: {
 products() {
 return this.$store.state.products;
 }
 }
};
```



# 循环浏览产品

当查看任何商店的类别列表时，显示的数据往往有一个重复出现的主题。它通常由图像、标题、价格和制造商组成。

将有序列表添加到您的模板中——因为产品将有一个顺序，所以将它们放在有序列表中是有语义意义的。在`<ol>`中，添加一个`v-for`循环遍历产品并显示每个产品的标题，如下所示。在继续显示之前，确保`product`变量存在也是一个很好的做法:

```
template: `<div v-if="products">
  <ol>
 <li v-for="product in products" v-if="product">
 <h3>{{ product.title }}</h3>
 </li>
 </ol>
</div>`,
```

在浏览器中查看页面时，您可能会注意到产品列表非常长。为这些产品中的每一个加载图像都会给用户的计算机带来巨大的负担，同时还会有那么多的产品展示给用户。在我们向模板添加更多信息(比如价格和图片)之前，我们将查看产品的分页，允许以更易于管理的块来访问数据。



# 创建分页

最初，创建分页似乎很简单–，因为您只需要返回固定数量的产品。然而，如果我们希望我们的分页能够与产品列表–互动，那就需要更高级一点。我们需要构建我们的分页，以便能够处理不同长度的产品–，以防我们的产品列表被过滤成更少的产品。



# 计算值

创建分页组件和显示正确产品背后的算法依赖于四个主要变量:

*   **每页项目数**:通常由用户设置；然而，我们将首先使用 12 这个固定的数字
*   **总件数**:显示的产品总数
*   **页数**:这可以用产品数除以每页的项目数来计算
*   当前页码:这个，结合其他的，将允许我们准确的返回我们需要的产品

从这些数字中，我们可以计算出分页所需的一切。这包括显示什么产品，是否显示下一个/上一个链接，如果需要，还包括跳转到不同链接的组件。

在我们继续之前，我们将把我们的`products`对象转换成一个数组。这允许我们对它使用 split 方法，这将允许我们返回特定的产品列表。这也意味着我们可以很容易地计算项目的总数。

更新您的`products`计算函数以返回一个`array`而不是一个`object`。这是通过使用`map()`功能–完成的，它是 ES2015 对简单`for`循环的替代。该函数现在返回一个包含产品对象的数组:

```
products() {
  let products = this.$store.state.products;
 return Object.keys(products).map(key => products[key]);
},
```

在名为`pagination`的计算对象中创建一个新函数。该函数将返回一个对象，其中包含关于分页的各种数字，例如总页数。这将允许我们创建产品列表并更新导航组件。如果我们的`products`变量有数据，我们只需要返回对象。该函数如以下代码片段所示:

```
computed: {
  products() {
    let products = this.$store.state.products;
    return Object.keys(products).map(key => products[key]);
  },

  pagination() {
 if(this.products) {

 return {

 }
 }
 }
},
```

我们现在需要跟踪两个变量–条目`perPage`和`currentPage`。在您的`HomePage`组件上创建一个`data`函数，并存储这两个变量。我们将给予用户稍后更新`perPage`变量的能力。突出显示的代码部分显示了我们的`data`功能:

```
const HomePage = {
  name: 'HomePage',

  template: `...`,

 data() {
 return {
 perPage: 12, 
 currentPage: 1
 }
 },

  computed: {
    ...
  }
};
```

You may be wondering when to use local data on a component and when to store the information in the Vuex store. This all depends on where you are going to be using the data and what is going to manipulating it. As a general rule, if only one component uses the data and manipulate it, then use the local `data()` function. However, if more than one component is going to be interacting with the variable, save it in the central store.

回到`pagination()`计算的函数，用`products`数组的长度存储一个变量。以此为变量，我们现在可以计算总页数。为了做到这一点，我们要做以下等式:

*每页产品/商品总数*

一旦我们有了这个结果，我们需要把它四舍五入到最接近的整数。这是因为如果有任何遗留问题，我们需要为它创建一个新页面。

例如，如果你每页显示 12 个商品，而你有 14 个产品，那么结果将是 1.1666 页–，这不是一个有效的页码。将这部分凑在一起可以确保我们有两页来展示我们的产品。为此，使用`Math.ceil()` JavaScript 函数。我们还可以将产品总数添加到我们的输出中。检查使用`Math.ceil()`功能的以下代码:

```
pagination() {
  if(this.products) {
    let totalProducts = this.products.length;

    return {
 totalProducts: totalProducts,
 totalPages: Math.ceil(totalProducts / this.perPage)
    }
  }
}
```

我们需要做的下一个计算是找出当前页面的当前产品范围。这有点复杂，因为我们不仅需要从页码中计算出我们需要什么，而且数组切片是基于项目索引–，这意味着第一个项目是`0`。

为了计算出我们的切片从哪里开始，我们可以使用以下计算:

*(当前页码*每页项数)-每页项数*

最后的减法可能看起来很奇怪，但它意味着在第`1`页，结果是`0`。这允许我们计算出需要在哪个索引处对`products`数组进行切片。

作为另一个例子，如果我们在第三页，结果将是 24，这是第三页将开始的地方。切片的结尾是这个结果*加上*每页的项目数。这样做的好处是，我们可以更新每页的项目，并且我们所有的计算都会更新。

用这两个结果–在`pagination`结果中创建一个对象，这将允许我们以后方便地访问它们:

```
pagination() {
  if(this.products) {
    let totalProducts = this.products.length,
      pageFrom = (this.currentPage * this.perPage) - this.perPage;

    return {
      totalProducts: totalProducts,
      totalPages: Math.ceil(totalProducts / this.perPage),
      range: {
 from: pageFrom,
 to: pageFrom + this.perPage
 }
    }
  }
}
```



# 显示分页列表

计算完分页属性后，我们现在可以使用开始点和结束点来操作我们的`products`数组。我们将使用一种方法来截断产品列表，而不是使用硬编码的值或使用另一个计算函数。这样做的好处是可以传递任何产品列表，同时也意味着 Vue 不会缓存结果。

用一个新的方法`paginate`在你的组件中创建一个新的方法对象。这应该接受一个参数，该参数将是我们要切片的`products`的数组。在函数中，我们可以使用之前计算的两个变量来返回正确的产品数量:

```
methods: {
  paginate(list) {
    return list.slice(
      this.pagination.range.from, 
      this.pagination.range.to
    );
  }
}
```

更新模板以在产品间循环时使用此方法:

```
template: `<div v-if="products">
  <ol>
    <li v-for="product in paginate(products)" v-if="product">
      <h3>{{ product.title }}</h3>
    </li>
  </ol>
</div>`,
```

我们现在可以在浏览器中查看它，并注意到它从我们的对象中返回前 12 个产品。将`data`对象中的`currentPage`变量更新为两个或三个将显示不同的产品列表，具体取决于数量。

为了继续我们列出产品的语义方法，当不在第一页时，我们应该更新有序列表的起始位置。这可以通过使用 HTML 属性`start`来实现——这允许你指定你应该从哪个数字开始一个有序列表。

使用`pagination.range.from`变量来设置我们的有序列表–的起点，记住添加`1`，因为在第一页上它将是`0`:

```
template: `<div v-if="products">
  <ol :start="pagination.range.from + 1">
    <li v-for="product in paginate(products)" v-if="product">
      <h3>{{ product.title }}</h3>
    </li>
  </ol>
</div>`
```

现在，当增加代码中的页码时，您会注意到有序列表从每页的适当位置开始。



# 创建分页按钮

通过代码更新页码对用户来说并不友好——所以我们应该添加一些页面来增加和减少页码变量。为此，我们将创建一个函数，将`currentPage`变量更改为它的值。这允许我们将它用于下一页 页面和上一页 上一页 页面按钮，如果需要还可以加上一个带编号的页面列表。

首先在您的`pagination`容器中创建两个按钮。如果我们处于导航的末端，我们希望禁用这些按钮——例如，当返回时，您不希望能够低于 `1` ，当前进时，您不希望能够超过最大页数。我们可以通过在按钮上设置 `disabled` 属性来做到这一点——就像我们在产品详细信息页面上所做的那样，并将当前页面与这些限制进行比较。

添加一个`disabled`属性，在上一页，按钮检查当前页是否是一页。在下一页按钮上，将其与我们的`pagination`方法的`totalPages`值进行比较。实现前面提到的属性的代码如下所示:

```
<button :disabled="currentPage == 1">Previous page</button>
<button :disabled="currentPage == pagination.totalPages">Next page</button>
```

将`currentPage`变量设置回`1`，并在浏览器中加载主页。您应该注意到上一页按钮被禁用了。如果你改变了`currentPage`变量，你会注意到按钮根据需要被激活或不激活。

我们现在需要为按钮创建一个点击方法来更新`currentPage`。创建一个名为`toPage()`的新函数。这应该接受单个变量–这将直接更新`currentPage`变量:

```
methods: {
 toPage(page) {
 this.currentPage = page;
 },

  paginate(list) {
    return list.slice(this.pagination.range.from, this.pagination.range.to);
  }
}
```

给按钮添加点击处理程序，对于下一页按钮，通过`currentPage + 1`，对于上一页按钮，通过`currentPage - 1`:

```
template: `<div v-if="products">
  <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
  <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>

  <ol :start="pagination.range.from + 1">
    <li v-for="product in paginate(products)" v-if="product">
      <h3>{{ product.title }}</h3>
    </li>
  </ol>
</div>`
```

我们现在可以在产品中来回导航。作为对用户界面的一个很好的补充，我们可以通过使用这里提到的代码使用我们可用的变量来给出页码和剩余页数的指示:

```
template: `<div v-if="products">
  <p>
 Page {{ currentPage }} out of {{ pagination.totalPages }}
 </p>
  <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
  <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>

  <ol :start="pagination.range.from + 1">
    <li v-for="product in paginate(products)" v-if="product">
      <h3>{{ product.title }}</h3>
    </li>
  </ol>
</div>`
```



# 更新导航上的 URL

对用户体验的另一个改进是更新页面导航上的 URL–这将允许用户共享 URL，将其加入书签，并在以后返回。分页时，页面是一个临时的*状态，不应该是 URL 的主要端点。相反，我们可以利用 Vue 路由器的查询参数。*

更新`toPage`方法，在页面更改时将参数添加到 URL。这可以通过使用`$router.push`来实现，但是，我们需要注意不要删除任何可能在将来用于过滤的现有参数。这可以通过将路线中的当前查询对象与包含`page`变量的新查询对象相结合来实现:

```
toPage(page) {
  this.$router.push({
 query: Object.assign({}, this.$route.query, {
 page
 })
 }); 
  this.currentPage = page;
},
```

当从一个页面导航到另一个页面时，您会注意到 URL 获得了一个与当前页面名称相同的新参数`?page=`。但是，按“刷新”不会产生正确的页面结果，而是再次显示第一页。这是因为我们需要将当前的`page`查询参数传递给我们的`HomePage`组件上的`currentPage`变量。

这可以通过使用`created()`函数–更新变量–来完成，确保我们已经首先检查了它的存在。`created`功能是 Vue 生命周期的一部分，在[第 4 章](part0076.html#28FAO0-985bf4ae118d4f62b18ae64204cb251c)、*使用 Dropbox API* 获取文件列表中有所涉及:

```
created() {
 if(this.$route.query.page) {
 this.currentPage = parseInt(this.$route.query.page);
 }
}
```

我们需要确保`currentPage`变量是一个整数，以帮助我们稍后需要做的任何算术，因为`string`不喜欢计算。



# 创建分页链接

当查看分页的产品时，最好有一个截断的页码列表，允许用户跳转几页。我们已经有了在页面之间导航的机制–这可以扩展它。

作为一个简单的入口点，我们可以通过循环直到到达`totalPages`值来创建到每个页面的链接。Vue 允许我们不用任何 JavaScript 就能做到这一点。在组件底部创建一个包含列表的`nav`元素。使用一个`v-for`，为`totalPages`变量中的每一项创建一个*变量`page`:*

```
<nav>
  <ol>
    <li v-for="page in pagination.totalPages">
      <button @click="toPage(page)">{{ page }}</button>
    </li>
  </ol>
</nav>
```

这将为每个页面创建一个按钮–例如，如果总共有 24 个页面，这将创建 24 个链接。这不是我们想要的效果，因为我们希望在当前页面的前后有几页。例如，如果当前页面是 15，页面链接应该是 12、13、14、15、16、17 和 18。这意味着有更少的链接，对用户来说不会太难。

首先，在`data`对象中创建一个新变量，该变量将记录所选页面的每一侧显示多少页–一个好的开始值是 3:

```
data() {
  return {
    perPage: 12, 
    currentPage: 1,
    pageLinksCount: 3
  }
},
```

接下来，创建一个名为`pageLinks`的新计算函数。该函数需要获取当前页面，并计算出比当前页面少三页和多三页的页码。从那里，我们需要检查下限范围不小于 1，上限不超过总页数。继续之前，请检查产品阵列是否有项目:

```
pageLinks() {
  if(this.products.length) {
    let negativePoint = parseInt(this.currentPage) - this.pageLinksCount,
      positivePoint = parseInt(this.currentPage) + this.pageLinksCount;

    if(negativePoint < 1) {
      negativePoint = 1;
    }

    if(positivePoint > this.pagination.totalPages) {
      positivePoint = this.pagination.totalPages;
    }

    return pages;
  }
}
```

最后一步是创建一个数组和一个从较低范围循环到较高范围的`for`循环。这将创建一个最多包含 7 个数字的数组，页面范围为:

```
pageLinks() {
  if(this.products.length) {
    let negativePoint = parseInt(this.currentPage) - this.pageLinksCount,
      positivePoint = parseInt(this.currentPage) + this.pageLinksCount,
      pages = [];

    if(negativePoint < 1) {
      negativePoint = 1;
    }

    if(positivePoint > this.pagination.totalPages) {
      positivePoint = this.pagination.totalPages;
    }

    for (var i = negativePoint; i <= positivePoint; i++) {
 pages.push(i)
 }

 return pages;
  }
}
```

我们现在可以用新的`pageLinks`变量替换导航组件中的`pagination.totalPages`变量，这样就会创建正确数量的链接，如下所示:

```
<nav>
  <ul>
    <li v-for="page in pageLinks">
      <button @click="toPage(page)">{{ page }}</button>
    </li>
  </ul>
</nav>
```

然而，在浏览器中查看它会呈现一些奇怪的行为。虽然会生成正确数量的链接，但点击它们或使用下一个/上一个按钮会使按钮保持不变–，即使您导航到按钮范围之外。这是因为计算值被缓存。我们可以用两种方法解决这个问题–要么将函数移动到`method`对象中，要么添加一个`watch`函数来查看路线并更新当前页面。

选择第二个选项意味着我们可以确保没有其他结果和输出被缓存并相应地更新。向组件添加一个`watch`对象，并将`currentPage`变量更新为页面查询变量的变量。确保它存在，否则默认为一个。`watch`方法如下图所示:

```
watch: {
  '$route'(to) {
    this.currentPage = parseInt(to.query.page) || 1;
  }
}
```

这确保了当导航到不同的页面时，所有计算的变量都会更新。打开您的`HomePage`组件，确保您的所有分页组件都相应地工作，并更新列表。



# 更新每页的项目

我们需要创建的最后一个用户界面是允许用户更新每页的产品数量。为了进行初始设置，我们可以创建一个带有直接更新值的`v-model`属性的`<select>`框。这将按预期工作，并相应地更新产品列表，如下所示:

```
template: `<div v-if="products">
  <p>
    Page {{ currentPage }} out of {{ pagination.totalPages }}
  </p>

 Products per page: 
 <select v-model="perPage">
 <option>12</option>
 <option>24</option>
 <option>48</option>
 <option>60</option>
 </select>

  <button @click="toPage(currentPage - 1)" :disabled="currentPage == 1">Previous page</button>
  <button @click="toPage(currentPage + 1)" :disabled="currentPage == pagination.totalPages">Next page</button>

  <ol :start="pagination.range.from + 1">
    <li v-for="product in paginate(products)" v-if="product">
      <h3>{{ product.title }}</h3>
    </li>
  </ol>

  <nav>
    <ul>
      <li v-for="page in pageLinks">
        <button @click="toPage(page)">{{ page }}</button>
      </li>
    </ul>
  </nav>
</div>
```

这种情况的问题是，一旦值发生变化，用户所在的页面可能会比可能的页面更高。例如，如果有 30 个产品，每页 12 个产品，这将创建三个页面。如果用户导航到第三页，然后选择每页 24 个产品，则只需要两个页面，第三页将是空的。

这也可以通过手表功能来解决。当`perPage`变量更新时，我们可以检查当前页面是否高于`totalPages`变量。如果是，我们可以将其重定向到最后一页:

```
watch: {
  '$route'(to) {
    this.currentPage = parseInt(to.query.page);
  },

  perPage() {
 if(this.currentPage > this.pagination.totalPages) {
 this.$router.push({
 query: Object.assign({}, this.$route.query, {
 page: this.pagination.totalPages
 })
 })
 }
 }
}
```



# 创建 ListProducts 组件

在我们继续创建过滤和排序之前，我们需要提取我们的产品列表逻辑，并将其模板化到我们的组件–中，以便我们可以轻松地重用它。这个组件应该接受一个属性`products`，它应该能够列出和分页。

打开`ListProducts.js`文件，将代码从`HomePage.js`文件复制到组件中。移动数据对象，复制`pagination`和`pageLinks`计算函数。将手表和方法对象以及`created()`功能从`HomePage`文件移动到`ListProducts`文件。

更新`HomePage`模板以使用带有`products`道具的`<list-products>`组件，传入`products`计算值。相比之下，`HomePage`组件现在应该要小得多:

```
const HomePage = {
  name: 'HomePage',

  template: `<div>
    <list-products :products="products"></list-products>
  </div>`,

  computed: {
    products() {
      let products = this.$store.state.products;
      return Object.keys(products).map(key => products[key]);
    }
  }
};
```

在`ListProducts`组件中，我们需要添加一个 props 对象，让组件知道将要发生什么。这一部分现在很重要。我们还需要向这个组件添加一些东西，以使它更加通用。它们包括:

*   如果有多个页面，则显示下一页/上一页链接
*   如果有超过 12 个产品，则显示“每页产品数”组件，如果产品数多于上一步，则仅显示每一步
*   如果它大于我们的`pageLinksCount`变量，只显示`pageLinks`组件

所有这些添加都已添加到以下组件代码中，如下所示。我们还删除了不必要的`products`计算值:

```
Vue.component('list-products', {
  template: `<div v-if="products">
    <p v-if="pagination.totalPages > 1">
      Page {{ currentPage }} out of {{ pagination.totalPages }}
    </p>

    <div v-if="pagination.totalProducts > 12">
      Products per page: 
      <select v-model="perPage">
        <option>12</option>
        <option>24</option>
        <option v-if="pagination.totalProducts > 24">48</option>
        <option v-if="pagination.totalProducts > 48">60</option>
      </select>
    </div>

    <button 
      @click="toPage(currentPage - 1)" 
      :disabled="currentPage == 1" 
      v-if="pagination.totalPages > 1"
    >
      Previous page
    </button>
    <button 
      @click="toPage(currentPage + 1)" 
      :disabled="currentPage == pagination.totalPages" 
      v-if="pagination.totalPages > 1"
    >
      Next page
    </button>

    <ol :start="pagination.range.from + 1">
      <li v-for="product in paginate(products)" v-if="product">
        <h3>{{ product.title }}</h3>
      </li>
    </ol>

    <nav v-if="pagination.totalPages > pageLinksCount">
      <ul>
        <li v-for="page in pageLinks">
          <button @click="toPage(page)">{{ page }}</button>
        </li>
      </ul>
    </nav>
  </div>`,

 props: {
 products: Array
 },

  data() {
    return {
      perPage: 12, 
      currentPage: 1,
      pageLinksCount: 3
    }
  },

  computed: {
    pagination() {
      if(this.products) {
        let totalProducts = this.products.length,
          pageFrom = (this.currentPage * this.perPage) - this.perPage,
          totalPages = Math.ceil(totalProducts / this.perPage);

        return {
          totalProducts: totalProducts,
          totalPages: Math.ceil(totalProducts / this.perPage),
          range: {
            from: pageFrom,
            to: pageFrom + this.perPage
          }
        }
      }
    },

    pageLinks() {
      if(this.products.length) {
        let negativePoint = this.currentPage - this.pageLinksCount,
          positivePoint = this.currentPage + this.pageLinksCount,
          pages = [];

        if(negativePoint < 1) {
          negativePoint = 1;
        }

        if(positivePoint > this.pagination.totalPages) {
          positivePoint = this.pagination.totalPages;
        }

        for (var i = negativePoint; i <= positivePoint; i++) {
          pages.push(i)
        }

        return pages;
      }
    }
  },

  watch: {
    '$route'(to) {
      this.currentPage = parseInt(to.query.page);
    },
    perPage() {
      if(this.currentPage > this.pagination.totalPages) {
        this.$router.push({
          query: Object.assign({}, this.$route.query, {
            page: this.pagination.totalPages
          })
        })
      }
    }
  },

  created() {
    if(this.$route.query.page) {
      this.currentPage = parseInt(this.$route.query.page);
    }
  },

  methods: {
    toPage(page) {
      this.$router.push({
        query: Object.assign({}, this.$route.query, {
          page
        })
      });

      this.currentPage = page;
    },

    paginate(list) {
      return list.slice(this.pagination.range.from, this.pagination.range.to)
    }
  }
});
```

您可以通过临时截断`HomePage`模板–中的产品数组来验证您的条件渲染标签是否有效，完成后不要忘记删除它:

```
products() {
  let products = this.$store.state.products;
  return Object.keys(products).map(key => products[key]).slice(1, 10);
}
```



# 为主页创建管理列表

有了产品列表组件，我们可以继续为主页制作一个精选的产品列表，并向产品列表添加更多信息。

在这个例子中，我们将在我们的主页组件上硬编码一个要显示的产品句柄数组。如果这是在发展中，你会希望这个列表是通过内容管理系统或类似的控制。

在您的`HomePage`组件上创建一个`data`函数，它包含一个名为`selectedProducts`的数组:

```
data() {
  return {
    selectedProducts: []
  }
},
```

用产品列表中的几个`handles`填充数组。尝试获取大约 6 个，但是如果超过 12 个，记住它将与我们的组件一起分页。将您选择的手柄添加到`selectedProducts`数组:

```
data() {
  return {
    selectedProducts: [
      'adjustable-stem',
 'colorful-fixie-lima',
 'fizik-saddle-pak',
 'kenda-tube',
 'oury-grip-set',
 'pure-fix-pedals-with-cages'
    ]
  }
},
```

使用我们选择的句柄，我们现在可以过滤产品列表，只包括包含在我们的`selectedProducts`数组中的产品列表。最初的直觉可能是结合使用产品数组上的 JavaScript `filter()`函数和`includes()`:

```
products() {
  let products = this.$store.state.products;

  products = Object.keys(products).map(key => products[key]);
  products = products.filter(product => this.selectedProducts.includes(product.handle));

  return products;
}
```

这样做的问题是，尽管它看起来可行，但它不考虑所选产品的顺序。筛选功能只是删除任何不匹配的项目，并按照产品的加载顺序保留剩余的产品。

幸运的是，我们的产品保存在一个以句柄为键的键/值对中。使用这个，我们可以利用 products 对象并使用一个`for`循环返回一个数组。

在计算函数中创建一个空数组`output`。遍历`selectedProducts`数组，找到每个需要的产品并添加到`output`数组中:

```
products() {
  let products = this.$store.state.products,
    output = [];

  if(Object.keys(products).length) {
 for(let featured of this.selectedProducts) {
 output.push(products[featured]);
 }
 return output;
 }
}
```

这将创建相同的产品列表，但这次是以正确的顺序。尝试重新排序、添加和删除项目，以确保您的列表做出相应的反应。



# 显示更多信息

我们现在可以在我们的`ListProduct`组件中显示更多的产品信息。正如本章开头提到的，我们应该显示:

*   图像
*   Title
*   价格
*   制造商

我们已经显示了标题，图像和制造商可以很容易地从产品信息中提取出来。不要忘记总是从`images`数组中检索第一幅图像。打开`ListProducts.js`文件并更新产品以显示此信息–确保在显示之前检查图像是否存在。制造商名称列在产品数据中的`vendor`对象下:

```
<ol :start="pagination.range.from + 1">
  <li v-for="product in paginate(products)" v-if="product">
    <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
    <h3>{{ product.title }}</h3>
    <p>Made by: {{ product.vendor.title }}</p>
  </li>
</ol>
```

价格会更复杂一点。这是因为产品的每种变化都有不同的价格，然而，这些价格通常是相同的。如果有不同的价格，我们应该显示最便宜的价格，并在前面加上来自的*。*

我们需要创建一个函数，循环遍历变量，计算出最便宜的价格，如果有价格范围，从添加单词*。为了实现这一点，我们将遍历这些变化，并构建一个唯一价格的数组–，如果该价格在数组中不存在的话。一旦完成，我们可以检查长度–如果有一个以上的价格，我们可以添加前缀，如果没有，这意味着所有的变化都是相同的价格。*

在`ListProducts`组件上创建一个名为`productPrice`的新方法。它接受一个参数，这个参数就是变量。内，创建一个空阵，`prices`:

```
productPrice(variations) {
  let prices = [];
}
```

循环遍历变量，如果价格不存在，则将价格追加到`prices`数组中。创建一个`for`循环，使用`includes()`函数检查价格是否存在于数组中:

```
productPrice(variations) {
  let prices = [];

  for(let variation of variations) {
 if(!prices.includes(variation.price)) {
 prices.push(variation.price);
 }
 }
}
```

有了我们的价格数组，我们现在可以提取最低的数字，并检查是否有一个以上的项目。

为了从数组中提取最小的数字，我们可以使用 JavaScript `Math.min()`函数。使用`.length`属性检查数组的长度。最后，返回`price`变量:

```
productPrice(variations) {
  let prices = [];

  for(let variation of variations) {
    if(!prices.includes(variation.price)) {
      prices.push(variation.price);
    }
  }

 let price = '$' + Math.min(...prices);

 if(prices.length > 1) {
 price = 'From: ' + price;
 }

  return price;
}
```

将您的`productPrice`方法添加到您的模板中，记住将`product.variationProducts`传递给它。我们需要添加到模板中的最后一件事是产品链接:

```
<ol :start="pagination.range.from + 1">
  <li v-for="product in paginate(products)" v-if="product">
    <router-link :to="'/product/' + product.handle">
      <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
    </router-link> 
    <h3>
      <router-link :to="'/product/' + product.handle">
        {{ product.title }}
      </router-link>
    </h3>

    <p>Made by: {{ product.vendor.title }}</p>
    <p>Price {{ productPrice(product.variationProducts) }}</p>
  </li>
</ol>
```

理想情况下，产品链接应该使用命名的路由，而不是硬编码的链接，以防路由发生变化。向产品路线添加一个名称，并更新`to`属性以使用该名称:

```
{
  path: '/product/:slug',
  name: 'Product',
  component: ProductPage
}
```

将模板更新为现在使用路线名称，带有`params`对象:

```
<ol :start="pagination.range.from + 1">
  <li v-for="product in paginate(products)" v-if="product">
    <router-link :to="{name: 'Product', params: {slug: product.handle}}">
      <img v-if="product.images[0]" :src="product.images[0].source" :alt="product.title" width="120">
    </router-link>
    <h3>
      <router-link :to="{name: 'Product', params: {slug: product.handle}}">
        {{ product.title }}
      </router-link>
    </h3>
    <p>Made by: {{ product.vendor.title }}</p>
    <p>Price {{ productPrice(product.variationProducts) }}</p>
  </li>
</ol>
```



# 创建类别

如果一个商店没有分类导航，它就不是一个真正有用的商店。幸运的是，我们的每件产品都有一个`type`键，指示它要展示的类别。我们现在可以创建一个类别页面，列出该特定类别的产品。



# 创建类别列表

在显示特定类别的产品之前，我们首先需要生成一个可用类别的列表。为了帮助我们的应用程序的性能，我们还将在每个类别中存储产品的句柄。类别结构将如下所示:

```
categories = {
  tools: {
    name: 'Tools',
    handle: 'tools',
    products: ['product-handle', 'product-handle'...]
  },
  freewheels: {
    name: 'Freewheels',
    handle: 'freewheels',
    products: ['another-product-handle', 'product'...]
  }
};
```

像这样创建类别列表意味着我们很容易获得该类别中的产品列表，同时能够遍历类别并输出`title`和`handle`来创建类别链接列表。因为我们已经有了这些信息，一旦检索到产品列表，我们将创建类别列表。

打开`app.js`并导航到`Vue`实例上的`created()`方法。我们将利用 Vuex–`actions`的不同功能，而不是在`products`存储方法下创建第二个`$store.commit`。

操作允许您在商店本身创建功能。动作不能直接改变状态–，这仍然取决于突变，但是它允许你将几个突变组合在一起，在这个例子中，这非常适合我们。如果您想在改变状态–之前运行一个异步操作，例如用一个`setTimeout` JavaScript 函数，动作也是完美的。

导航到您的`Vuex.Store`实例，在突变之后，添加一个新的`actions`对象。在里面，创建一个名为`initializeShop`的新函数:

```
const store = new Vuex.Store({
  state: {
    products: {}
  },

  mutations: {
    products(state, payload) {
      state.products = payload;
    }
  },

 actions: {
 initializeShop() {

 }
 }
});
```

对于动作参数，第一个参数是存储本身，我们需要使用它来利用突变。有两种方法可以做到这一点，第一种是使用单个变量并在函数中访问它的属性。例如:

```
actions: {
  initializeShop(store) {
    store.commit('products');
  }
}
```

但是，在 ES2015 中，我们能够使用参数析构并利用我们需要的属性。对于这个动作，我们只需要`commit`函数，就像这样:

```
actions: {
  initializeShop({commit}) {
    commit('products');
  }
}
```

如果我们也想从商店得到州，我们可以把它加到花括号里:

```
actions: {
  initializeShop({state, commit}) {
    commit('products');
    // state.products
  }
}
```

使用这种访问属性的“分解”方法使我们的代码更加简洁，重复性更低。删除`state`属性，并在标有`products`的花括号后添加第二个参数。这将是我们格式化产品的数据。将该变量直接传递给产品的`commit`函数:

```
initializeShop({commit}, products) {
  commit('products', products);
}
```

使用动作和使用`mutations`一样简单，除了不用`$store.commit`，而是使用`$store.dispatch`。更新你的`created`方法–不要忘记更改函数名，并检查你的应用程序是否仍然工作:

```
created() {
  CSV.fetch({url: './data/csv-files/bicycles.csv'}).then(data => {
    this.$store.dispatch('initializeShop', this.$formatProducts(data));
  });
}
```

下一步是为我们的类别创建一个变种。由于我们可能希望独立于我们的产品更新我们的类别–，我们应该在`mutations`中创建第二个函数。也应该是这个函数遍历产品并创建类别列表。

首先，在状态对象中创建一个名为`categories`的新属性。默认情况下，这应该是一个对象:

```
state: {
  products: {},
  categories: {}
}
```

接下来，创建一个名为`categories`的新突变。除了状态之外，这还需要第二个参数。为了保持一致，将其命名为`payload`–，因为 Vuex 是这样称呼它的:

```
mutations: {
  products(state, payload) {
    state.products = payload;
  },

 categories(state, payload) {

 }
},
```

现在是功能性。这种突变需要在产品中循环。对于每个产品，都需要隔离`type`。一旦它有了标题和 slug，它需要检查是否存在带有该 slug 的条目；如果是，将产品句柄附加到`products`数组，如果不是–，它需要创建一个新的数组和细节。

创建一个空的`categories`对象并遍历有效负载，为产品和类型设置一个变量:

```
categories(state, payload) {
 let categories = {}; 
 Object.keys(payload).forEach(key => {
 let product = payload[key],
 type = product.type;
 });
}
```

我们现在需要检查是否存在带有当前`type.handle`关键字的条目。如果没有，我们需要用它创建一个新条目。条目需要有标题、句柄和一个空的产品数组:

```
categories(state, payload) {
  let categories = {};

  Object.keys(payload).forEach(key => {
    let product = payload[key],
      type = product.type;

 if(!categories.hasOwnProperty(type.handle)) {
 categories[type.handle] = {
 title: type.title,
 handle: type.handle,
 products: []
 }
 }
  });
}
```

最后，我们需要将当前产品句柄追加到条目的产品数组中:

```
categories(state, payload) {
  let categories = {};

  Object.keys(payload).forEach(key => {
    let product = payload[key],
      type = product.type;

    if(!categories.hasOwnProperty(type.handle)) {
      categories[type.handle] = {
        title: type.title,
        handle: type.handle,
        products: []
      }
    }

    categories[type.handle].products.push(product.handle);
  });
}
```

您可以通过在函数末尾添加`console.log`来查看`categories`输出:

```

categories(state, payload) {
  let categories = {};

  Object.keys(payload).forEach(key => {
    ...
  });

  console.log(categories);
}
```

将变异添加到 `initializeShop` 动作:

```
initializeShop({commit}, products) {
  commit('products', products);
  commit('categories', products);
}
```

在浏览器中查看应用程序时，您将面临一个 JavaScript 错误。这是因为有些产品不包含我们用来分类的“类型”。即使解决了 JavaScript 错误，仍然有许多类别被列出。

为了增加类别的数量，并对未分类的产品进行分组，我们应该创建一个“杂项”类别。这将整理包含两个或更少产品的所有类别，并将产品归入各自的组。



# 创建“杂项”类别

我们需要否定的第一个问题是无名范畴。当遍历我们的产品时，如果没有找到类型，我们应该插入一个类别，这样所有的东西都被分类了。

在`categories`方法中创建一个新对象，其中包含一个新类别的标题和句柄。对于句柄和变量，称它为 other。将标题命名为<q class="calibre31">杂项</q>，使其更加用户友好。

```
let categories = {},
  other = {
 title: 'Miscellaneous',
 handle: 'other'
 };
```

当循环遍历产品时，我们可以检查`type`键是否存在，如果不存在，创建一个`other`类别并附加到它:

```
Object.keys(payload).forEach(key => {
  let product = payload[key],
    type = product.hasOwnProperty('type') ? product.type : other;

  if(!categories.hasOwnProperty(type.handle)) {
    categories[type.handle] = {
      title: type.title,
      handle: type.handle,
      products: []
    }
  }

  categories[type.handle].products.push(product.handle);
});
```

现在查看应用程序将显示 JavaScript 控制台–中的所有类别，让您可以看到类别的数量。

让我们将任何包含两个或更少产品的类别合并到“其他”类别–中，不要忘记之后删除该类别。在产品循环之后，遍历类别，检查可用产品的数量。如果少于三个，将其添加到“其他”类别:

```
Object.keys(categories).forEach(key => {
  let category = categories[key];

  if(category.products.length < 3) {
    categories.other.products = categories.other.products.concat(category.products);
  }
});
```

然后，我们可以删除刚刚被盗产品的类别:

```
Object.keys(categories).forEach(key => {
  let category = categories[key];

  if(category.products.length < 3) {
    categories.other.products = categories.other.products.concat(category.products);
    delete categories[key];
  }
});
```

这样，我们就有了一个更易于管理的类别列表。我们可以做的另一个改进是确保类别按字母顺序排列。这有助于用户更快地找到他们想要的类别。在 JavaScript 中，数组的排序比对象容易得多，所以我们再次需要遍历对象键的数组并对它们进行排序。创建一个新对象，并在分类时添加类别。之后，将它存储在`state`对象上，这样我们就有了可用的类别:

```
categories(state, payload) {
  let categories = {},
    other = {
      title: 'Miscellaneous',
      handle: 'other'
    };

  Object.keys(payload).forEach(key => {
    let product = payload[key],
      type = product.hasOwnProperty('type') ? product.type : other;

    if(!categories.hasOwnProperty(type.handle)) {
      categories[type.handle] = {
        title: type.title,
        handle: type.handle,
        products: []
      }
    }

    categories[type.handle].products.push(product.handle);
  });

  Object.keys(categories).forEach(key => {
    let category = categories[key];

    if(category.products.length < 3) {
      categories.other.products =      categories.other.products.concat(category.products);
      delete categories[key];
    }
  });

  let categoriesSorted = {}
 Object.keys(categories).sort().forEach(key => {
 categoriesSorted[key] = categories[key]
 });
 state.categories = categoriesSorted;
}
```

这样，我们现在可以将类别列表添加到我们的`HomePage`模板中。为此，我们将创建名为`router-view`的组件–，允许我们在商店的侧边栏中选择页面。



# 显示类别

存储了类别后，我们现在可以继续创建我们的`ListCategories`组件。我们希望在主页的侧边栏中显示我们的类别导航，也在商店类别页面上显示。因为我们想在几个地方展示它，所以我们有几个展示方式的选择。

我们可以像使用`<list-products>`组件一样使用模板中的组件。这样做的问题是，如果我们想在侧边栏中显示我们的列表，并且我们的侧边栏需要在整个站点中保持一致，我们将不得不在视图之间复制和粘贴大量的 HTML。

更好的方法是使用命名路由，并在我们的`index.html`中设置一次模板。

更新应用程序模板以包含一个`<main>`和一个`<aside>`元素。在这些元素中，创建一个`router-view`，不命名`main`中的元素，而给`aside`元素中的元素命名为`sidebar`:

```
<div id="app">
  <main>
    <router-view></router-view>
  </main>
 <aside>
 <router-view name="sidebar"></router-view>
 </aside>
</div>
```

在我们的 routes 对象中，我们现在可以向不同的命名视图添加不同的组件。在`Home`路径上，将`component`键改为`components`，并添加一个对象——指定每个组件及其视图:

```
{
  path: '/',
  name: 'Home',
  components: {
 default: HomePage,
 sidebar: ListCategories
 }
}
```

默认表示组件将进入未命名的`router-view`。这允许我们在需要时仍然使用单数`component`键。为了将组件正确加载到侧边栏视图中，我们需要改变`ListCategories`组件的初始化方式。不要使用`Vue.component`，像初始化`view`组件一样初始化它:

```
const ListCategories = {
  name: 'ListCategories'

};
```

我们现在可以继续制作类别列表的模板了。由于我们的类别保存在商店中，加载和显示它们现在应该很熟悉了。建议您将状态中的类别加载到一个计算函数中——这样可以使模板代码更简洁，在您需要以任何方式操作它时也更容易适应。

在我们创建模板之前，我们需要为类别创建一个路由。回头参考我们在[第 9 章](part0156.html#4KONO0-985bf4ae118d4f62b18ae64204cb251c)、*中的计划，使用 Vue-Router 动态路由来加载数据*，我们可以看到路由将会是`/category/:slug`–添加带有`name`的路由并启用道具，因为我们将在`slug`中使用它们。确保您已经创建了`CategoryPage`文件并初始化了组件。

```
const router = new VueRouter({
  routes: [
    {
      path: '/',
      name: 'Home',
      components: {
        default: HomePage,
        sidebar: ListCategories
      }
    },
    {
 path: '/category/:slug',
 name: 'Category',
 component: CategoryPage,
 props: true
 },
    {
      path: '/product/:slug',
      name: 'Product',
      component: ProductPage
    },

    {
      path: '/404', 
      alias: '*',
      component: PageNotFound
    }
  ]
});
```

回到我们的`ListCategories`组件；遍历存储的类别，并为每个类别创建一个链接。在每个名称后的括号中显示产品数量:

```
const ListCategories = {
  name: 'ListCategories',

 template: `<div v-if="categories">
 <ul>
 <li v-for="category in categories">
 <router-link :to="{name: 'Category', params: {slug: category.handle}}">
 {{ category.title }} ({{ category.products.length }})
 </router-link>
 </li>
 </ul>
 </div>`,

 computed: {
 categories() {
 return this.$store.state.categories;
 }
 } 
};
```

现在主页上显示了我们类别的链接，我们可以开始制作类别页面了。



# 在类别中显示产品

点击其中一个类别链接(即`/#/category/grips`)将会导航到一个空白页面–，感谢我们的路线。我们需要创建一个模板，并设置类别页面来显示产品。作为起点，以类似于产品页面的方式创建`CategoryPage`组件。

创建一个包含空容器和`PageNotFound`组件的模板。创建一个名为`categoryNotFound`的数据变量，如果设置为`true`，确保显示`PageNotFound`组件。创建一个`props`对象，它允许传递`slug`属性，最后创建一个`category`计算函数。

`CategoryPage`组件应该如下所示:

```
const CategoryPage = {
  name: 'CategoryPage',

  template: `<div>
    <div v-if="category"></div>
    <page-not-found v-if="categoryNotFound"></page-not-found>
  </div>`,

  components: {
    PageNotFound
  },

  props: {
    slug: String
  },

  data() {
    return {
      categoryNotFound: false,
    }
  },

  computed: {
    category() {
    }
  }
};
```

在`category`计算函数中，根据 slug 从存储中加载正确的类别。如果它不在列表中，将`categoryNotFound`变量标记为 true——类似于我们在`ProductPage`组件中所做的:

```
computed: {
  category() {
    let category;

 if(Object.keys(this.$store.state.categories).length) {

 category = this.$store.state.categories[this.slug];

 if(!category) {
 this.categoryNotFound = true;
 }
 }

 return category;
  }
}
```

加载类别后，我们可以在模板中输出标题:

```
template: `<div>
  <div v-if="category">
    <h1>{{ category.title }}</h1>
  </div>
  <page-not-found v-if="categoryNotFound"></page-not-found>
</div>`,
```

我们现在可以继续在我们的类别页面上展示产品了。为此，我们可以使用来自`HomePage`组件的代码，因为我们有完全相同的场景–一系列产品句柄。

创建一个新的`computed`函数，该函数获取当前类别的产品，并像我们在主页上所做的那样处理它们:

```
computed: {
  category() {
    ...
  },

  products() {
    if(this.category) {
 let products = this.$store.state.products,
 output = [];

 for(let featured of this.category.products) {
 output.push(products[featured]);
 }

 return output; 
 }
  }
}
```

我们不需要检查产品是否存在于该函数中，因为我们正在检查类别是否存在，并且只有在数据已被加载的情况下才会返回 true。将组件添加到 HTML 并传入`products`变量:

```
template: `<div>
  <div v-if="category">
    <h1>{{ category.title }}</h1>
    <list-products :products="products"></list-products>
  </div>
  <page-not-found v-if="categoryNotFound"></page-not-found>
</div>`
```

这样，我们就可以列出每个类别的产品。



# 代码优化

随着我们的`CategoryPage`组件的完成，我们可以看到它和主页–之间有很多相似之处，唯一的不同是主页有一个固定的产品数组。为了避免重复，我们可以组合这两个组件–，这意味着如果需要的话，我们只需要更新其中一个。

我们可以通过在主页上显示固定数组来解决这个问题。方法是检查废料浆道具是否有值。如果没有，我们可以假设我们在主页上。

首先，更新`Home`路由指向`CategoryPage`组件并启用 props。当使用命名视图时，您必须为每个视图启用 props。将 props 值更新为每个命名视图的对象，为每个视图启用 props:

```
{
  path: '/',
  name: 'Home',
  components: {
    default: CategoryPage,
    sidebar: ListCategories
  },
  props: {
 default: true, 
 sidebar: true
 }
}
```

接下来，在`CategoryPage`的`data`函数中创建一个新变量，名为`categoryHome`。这将是一个遵循与类别对象相同结构的对象，包含一个`products`数组、标题和句柄。虽然不会使用句柄，但是遵循以下约定是一个很好的做法:

```
data() {
  return {
    categoryNotFound: false,
    categoryHome: {
 title: 'Welcome to the Shop',
 handle: 'home',
 products: [
 'adjustable-stem',
 'fizik-saddle-pak',
 'kenda-tube',
 'colorful-fixie-lima',
 'oury-grip-set',
 'pure-fix-pedals-with-cages'
 ]
 }
  }
}
```

我们需要做的最后一件事是检查弹头是否存在。否则，将我们的新对象赋给计算函数中的 category 变量:

```
category() {
  let category;

  if(Object.keys(this.$store.state.categories).length) {
    if(this.slug) {
 category = this.$store.state.categories[this.slug];
 } else {
 category = this.categoryHome;
 }

    if(!category) {
      this.categoryNotFound = true;
    }
  }

  return category;
}
```

转到主页，验证您的新组件正在工作。如果是，可以删除`HomePage.js`，将其从`index.html`中移除。更新类别路径，在侧边栏中包含类别列表，并使用`props`对象:

```
{
  path: '/category/:slug',
  name: 'Category',
  components: {
 default: CategoryPage,
 sidebar: ListCategories
 },
  props: {
 default: true, 
 sidebar: true
 }
},
```



# 订购某一类别的产品

随着我们的分类页面显示正确的产品，是时候在我们的`ListProducts`组件中添加一些订购选项了。浏览网上商店时，您通常可以通过以下方式订购产品:

*   标题:升序(A - Z)
*   标题:下降(Z - A)
*   价格:递增(1-999 美元)
*   价格:递减(999-1 美元)

然而，一旦我们有了合适的机制，您可以添加任何您想要的订购标准。

首先，在您的`ListProducts`组件中创建一个选择框，包含前面的每个值。添加额外的第一个产品排序依据...:

```
<div class="ordering">
  <select>
    <option>Order products</option>
    <option>Title - ascending (A - Z)</option>
    <option>Title - descending (Z - A)</option>
    <option>Price - ascending ($1 - $999)</option>
    <option>Price - descending ($999 - $1)</option>
  </select>
</div>
```

我们现在需要为选择框创建一个变量，以便在`data`函数中更新。添加一个名为`ordering`的新键，并为每个选项添加一个值，这样解释这个值就更容易了。使用由连字符分隔的字段和顺序来构造值。例如，`Title - ascending (` A - Z `)`会变成`title-asc`:

```
<div class="ordering">
  <select v-model="ordering">
    <option value="">Order products</option>
    <option value="title-asc">Title - ascending (A - Z)</option>
    <option value="title-desc">Title - descending (Z - A)</option>
    <option value="price-asc">Price - ascending ($1 - $999)</option>
    <option value="price-desc">Price - descending ($999 - $1)</option>
  </select>
</div>
```

更新后的`data`函数变为:

```
data() {
  return {
    perPage: 12, 
    currentPage: 1,
    pageLinksCount: 3,

    ordering: ''
  }
}
```

为了更新产品的订单，我们现在需要操作产品列表。这需要在列表被分页之前完成——因为用户希望整个列表都被排序，而不仅仅是当前页面。



# 存储产品价格

在我们继续之前，有一个问题需要解决。要按价格排序，价格需要理想地在产品本身上可用，而不是像现在这样专门为模板计算。为了解决这个问题，我们将在产品进入商店之前计算价格。这意味着它将作为产品本身的一个属性，而不是动态创建的。

我们需要知道的细节是最便宜的价格，以及该产品在其变化范围内是否有许多价格。后者意味着我们知道在列出产品时是否需要显示`"From:"`。我们将为的每个产品创建两个新属性:`price`和`hasManyPrices`。

导航到商店中的`products`突变，创建一个新对象和一个产品循环:

```
products(state, payload) {
 let products = {};

 Object.keys(payload).forEach(key => {
 let product = payload[key];

 products[key] = product;
 });

  state.products = payload;
}
```

从`ListProducts`组件上的`productPrice`方法中复制代码，并将其放入循环中。更新第二个`for`循环，使其循环通过`product.variationProducts`。一旦这个`for`循环完成，我们就可以给产品添加新的属性。最后，用新产品对象更新状态:

```
products(state, payload) {
  let products = {};

  Object.keys(payload).forEach(key => {
    let product = payload[key];

    let prices = [];
 for(let variation of product.variationProducts) {
 if(!prices.includes(variation.price)) {
 prices.push(variation.price);
 }
 }

 product.price = Math.min(...prices);
 product.hasManyPrices = prices.length > 1;

    products[key] = product;
  });

  state.products = products;
}
```

我们现在可以更新`ListProducts`组件上的`productPrice`方法。更新函数，使其接受产品，而不是变体。从函数中删除`for`循环，并更新变量，使它们使用产品的`price`和`hasManyPrices`属性:

```
productPrice(product) {
  let price = '$' + product.price;

  if(product.hasManyPrices) {
    price = 'From: ' + price;
  }

  return price;
}
```

更新模板，以便将产品传递给函数:

```
<p>Price {{ productPrice(product) }}</p>
```



# 连接订单

有了我们现成的价格，我们就可以着手安排订货了。创建一个名为`orderProducts`的新`computed`函数，返回`this.products`。我们希望确保我们总是从源头进行分类，而不是订购以前已经订购过的东西。从`paginate`函数中调用这个新函数，并从这个方法和模板中删除参数:

```
computed: {
 ...

  orderProducts() {
 return this.products;
 }, },

methods: {
  paginate() {
    return this.orderProducts.slice(
      this.pagination.range.from,  
      this.pagination.range.to
    );
  },
}
```

为了确定我们需要如何对产品进行排序，我们可以使用`this.ordering`值。如果它存在，我们可以在连字符上分割字符串，这意味着我们有一个包含字段和订单类型的数组。如果它不存在，我们只需返回现有的产品数组:

```
orderProducts() {
  let output;

 if(this.ordering.length) {
 let orders = this.ordering.split('-');
 } else {
 output = this.products;
 }
 return output;
}
```

根据排序数组第一项的值对`products`数组进行排序。如果是字符串，我们就用`localCompare`，比较时忽略大小写。否则，我们将简单地从另一个值中减去一个值–这是`sort`函数所期望的:

```
orderProducts() {
  let output;

  if(this.ordering.length) {
    let orders = this.ordering.split('-');

    output = this.products.sort(function(a, b) {
 if(typeof a[orders[0]] == 'string') {
 return a[orders[0]].localeCompare(b[orders[0]]);
 } else {
 return a[orders[0]] - b[orders[0]];
 }
 });

  } else {
    output = this.products;
  }
  return output;
}
```

最后，我们需要检查`orders`数组中的第二项是`asc`还是`desc`。默认情况下，当前排序函数将返回按`ascending`顺序排序的项目，因此如果值为`desc`，我们可以反转数组:

```
orderProducts() {
  let output;

  if(this.ordering.length) {
    let orders = this.ordering.split('-');

    output = this.products.sort(function(a, b) {
      if(typeof a[orders[0]] == 'string') {
        return a[orders[0]].localeCompare(b[orders[0]]);
      } else {
        return a[orders[0]] - b[orders[0]];
      }
    });

 if(orders[1] == 'desc') {
 output.reverse();
 }
  } else {
    output = this.products;
  }
  return output;
}
```

打开您的浏览器，查看产品订单！



# 创建 Vuex 吸气剂

让我们的分类页面像其他商店一样的最后一步是引入过滤。过滤允许您查找具有特定尺寸、颜色、标签或制造商的产品。我们的过滤选项将从页面上的产品中构建。例如，如果没有一个产品是 XL 尺寸或蓝色的，那么显示它作为过滤器就没有意义。

为此，我们还需要将当前类别的产品传递给过滤组件。然而，产品是在`CategoryPage`组件上加工的。我们可以将功能转移到 Vuex 商店`getter`，而不是重复这个过程。Getters 允许您从存储中检索数据，并像在组件的函数中一样操作它。但是，因为它是一个中心位置，这意味着几个组件可以从处理中受益。

Getters 是计算函数的 Vuex 等价物。它们被声明为函数，但被称为变量。但是，可以通过在它们内部返回一个函数来操作它们以接受参数。

我们将把`category`和`products`函数从`CategoryPage`组件移到 getter 中。`getter`函数将返回一个包含类别和产品的对象。

在商店中创建一个名为`getters`的新对象。在内部，创建一个名为`categoryProducts`的新函数:

```
getters: {
  categoryProducts: () => {

  }
}
```

getter 本身接收两个参数，第一个是状态，第二个是其他 getter。要将参数传递给 getter，必须在 getter 内部返回一个接收参数的函数。幸运的是，在 ES2015 中，这可以通过双箭头(`=>`)语法来实现。因为我们不会在这个函数中使用任何其他的 getters，所以我们不需要调用第二个参数。

当我们抽象出所有的逻辑时，传入`slug`变量作为第二个函数的参数:

```
categoryProducts: (state) => (slug) => {

}
```

当我们将选择和检索类别和产品的逻辑转移到商店中时，将`HomePage`类别内容存储在 `state` 本身:中是有意义的

```
state: {
  products: {},
  categories: {},

  categoryHome: {
 title: 'Welcome to the Shop',
 handle: 'home',
 products: [
 'adjustable-stem',
 'fizik-saddle-pak',
 'kenda-tube',
 'colorful-fixie-lima',
 'oury-grip-set',
 'pure-fix-pedals-with-cages'
 ]
 }
}
```

将类别选择逻辑从`CategoryPage`组件中的`category`计算函数移到 getter 中。更新`slug`和`categoryHome`变量以使用相关位置的内容:

```
categoryProducts: (state) => (slug) => {
  if(Object.keys(state.categories).length) {
    let category = false;

    if(slug) {
      category = this.$store.state.categories[this.slug];
    } else {
      category = state.categoryHome;
    }
  }
}
```

分配了类别后，我们现在可以根据类别中存储的句柄来加载产品。将代码从`products`计算函数移到 getter 中。将变量赋值组合在一起，并删除 store product retrieval 变量，因为我们已经有了可用的状态。确保检查类别是否存在的代码仍然存在:

```
categoryProducts: (state) => (slug) => {
  if(Object.keys(state.categories).length) {
    let category = false,
      products = [];

    if(slug) {
      category = this.$store.state.categories[this.slug];
    } else {
      category = state.categoryHome;
    }

    if(category) {
 for(let featured of category.products) {
 products.push(state.products[featured]);
 }
 }
  }
}
```

最后，我们可以用充实的产品数据在`category`上添加一个新的`productDetails`数组。在函数结束时返回`category`。如果`slug`变量输入作为一个类别存在，我们将得到所有的数据。如果没有，它将返回`false`–，从中我们可以显示我们的`PageNotFound`组件:

```
categoryProducts: (state) => (slug) => {
  if(Object.keys(state.categories).length) {
    let category = false,
      products = [];

    if(slug) {
      category = state.categories[slug];
    } else {
      category = state.categoryHome;
    }

    if(category) {
      for(let featured of category.products) {
        products.push(state.products[featured]);
      }

      category.productDetails = products;
    }

    return category;
  }
}
```

在我们的`CategoryPage`组件中，我们可以移除`products()`计算函数并更新`category()`函数。要调用`getter`函数，请参考`this.$store.getters`:

```
computed: {
  category() {
    if(Object.keys(this.$store.state.categories).length) {
      let category = this.$store.getters.categoryProducts(this.slug);

      if(!category) {
        this.categoryNotFound = true;
      }
      return category;
    }
  }
}
```

不幸的是，在继续之前，我们仍然需要检查这些类别是否存在。这样我们就可以知道没有一个类别是这个名字，而不是一个未加载的类别。

为了更简洁，我们可以将这个检查提取到另一个 getter 中，并在我们的另一个 getter 和组件中使用它。

创建一个名为`categoriesExist`的新 getter，并返回`if`语句的内容:

```
categoriesExist: (state) => {
  return Object.keys(state.categories).length;
},
```

更新`categoryProducts` getter 以接受第一个函数的参数中的 getter，并使用这个新的 getter 来指示其输出:

```
categoryProducts: (state, getters) => (slug) => {
  if(getters.categoriesExist) {
    ...
  }
}
```

在我们的`CategoryPage`组件中，我们现在可以用`this.$store.getters.categoriesExist()`调用新的 getter。为了避免在这个函数中重复使用`this.$store.getters`,我们可以将 getters 映射到本地访问。这允许我们调用`this.categoriesExist()`作为一个可读性更好的函数名。

在`computed`对象的开头，添加一个名为`...Vuex.mapGetters()`的新函数。该函数接受一个数组或一个对象作为参数，开头的三个点确保内容被扩展以与`computed`对象合并。

传入包含两个 getters 名称的数组:

```
computed: {
 ...Vuex.mapGetters([
 'categoryProducts',
 'categoriesExist'
 ]),

  category() {
    ...
  }
}
```

这意味着我们现在有`this.categoriesExist`和`this.categoryProducts`可以支配。更新类别函数以使用这些新函数:

```
computed: {
  ...Vuex.mapGetters([
    'categoriesExist',
    'categoryProducts'
  ]),

  category() {
    if(this.categoriesExist) {
      let category = this.categoryProducts(this.slug);

      if(!category) {
        this.categoryNotFound = true;
      }
      return category;
    }
  }
}
```

更新模板以反映计算数据的变化:

```
template: `<div>
  <div v-if="category">
    <h1>{{ category.title }}</h1>
    <list-products :products="category.productDetails"></list-products>
  </div>
  <page-not-found v-if="categoryNotFound"></page-not-found>
</div>`,
```



# 基于产品构建过滤组件

如上所述，我们所有的过滤器都将从当前类别的产品中创建。这意味着如果没有由 *IceToolz* 制造的产品，它将不会显示为可用的过滤器。

首先，打开`ProductFiltering.js`组件文件。我们的产品过滤将放在我们的侧边栏中，因此将组件定义从`Vue.component`更改为一个对象。我们仍然希望在过滤后显示我们的类别，所以添加`ListCategories`组件作为在`ProductFiltering`中声明的组件。添加一个模板键并包含`<list-categories>`组件:

```
const ProductFiltering = {
  name: 'ProductFiltering',

  template: `<div>
    <list-categories />
  </div>`,

  components: {
    ListCategories
  }
}
```

更新类别 route，在侧边栏中包含`ProductFiltering`组件，而不是`ListCategories`:

```
{
  path: '/category/:slug',
  name: 'Category',
  components: {
    default: CategoryPage,
    sidebar: ProductFiltering
  },
  props: {
    default: true, 
    sidebar: true
  }
}
```

现在您应该有了包含`CategoryPage`和`ListCategories`组件的`Home`路线，以及包含`ProductFiltering`组件的`Category`路线。

从`CategoryPage`组件中，复制道具和计算对象——因为我们将利用大量现有代码。将`category`计算函数重命名为`filters`。删除 return 和`componentNotFound` if 语句。您的组件现在应该如下所示:

```
const ProductFiltering = {
  name: 'ProductFiltering',

  template: `<div>
    <list-categories />
  </div>`,

  components: {
    ListCategories
  },

  props: {
 slug: String
 },

 computed: {
 ...Vuex.mapGetters([
 'categoriesExist',
 'categoryProducts'
 ]),
 filters() {
 if(this.categoriesExist) {
 let category = this.categoryProducts(this.slug);

 }
 }
 }
}
```

我们现在需要根据类别中的产品来构建我们的过滤器。我们将通过遍历产品、从预选值中收集信息并显示它们来实现这一点。

创建一个包含关键字`topics`的`data`对象。这将是一个包含子对象的对象，对于我们想要过滤的每一个属性，子对象都有一个熟悉的`'handle': {}`模式。

每个子对象将包含一个`handle`，它是要过滤的产品的值(例如，vendor)，一个`title`，它是键的用户友好版本，以及一个将被填充的值数组。

我们将从两个开始，`vendor`和`tags`；但是，随着我们对产品的处理，将会动态添加更多内容:

```
data() {
  return {
    topics: {
      vendor: {
        title: 'Manufacturer',
        handle: 'vendor',
        values: {}
      },
      tags: {
        title: 'Tags',
        handle: 'tags',
        values: {}
      }
    }
  }
},
```

我们现在开始循环浏览产品。除了这些值，我们还将跟踪有多少产品具有相同的值，从而允许我们向用户指示将显示多少产品。

在`filters`方法中遍历类别上的`products`，首先，找到每个产品的`vendor`。对于遇到的每一个，检查它是否存在于`values`数组中。

如果没有，添加一个带有`name`、`handle`和`count`的新对象，这是一个产品句柄数组。我们存储了一个句柄数组，这样我们就可以验证产品是否已经被看到。如果我们保存一个原始的数字计数，我们可能会遇到过滤器被触发两次，计数加倍的情况。通过检查产品句柄是否已经存在，我们可以检查它是否只出现过一次。

如果该名称的过滤器确实存在，请在检查它不存在后将句柄添加到数组中:

```
filters() {
  if(this.categoriesExist) {

    let category = this.categoryProducts(this.slug),
      vendors = this.topics.vendor;

 for(let product of category.productDetails) {

        if(product.hasOwnProperty('vendor')) {
 let vendor = product.vendor; 
 if(vendor.handle) { if(!vendor.handle.count.includes(product.handle)) {
              category.values[item.handle].count.push(product.handle);
            }
          } else {
 vendors.values[vendor.handle] = {
 ...vendor,
 count: [product.handle]
 }
 }
 } 
 }

 }
  }
}
```

这利用了以前使用的对象扩展省略号(`...`)，使我们不必写:

```
vendors.values[product.vendor.handle] = {
  title: vendor.title,
 handle: vendor.handle,
  count: [product.handle]
}
```

不过，如果你觉得更舒服的话，也可以随意使用。

复制代码来处理`tags`，但是由于`tags`本身是一个数组，我们需要遍历每个标签并相应地添加:

```
for(let product of category.productDetails) {

  if(product.hasOwnProperty('vendor')) {
    let vendor = product.vendor;

    if(vendor.handle) {
      if(!vendor.handle.count.includes(product.handle)) {
        category.values[item.handle].count.push(product.handle);
      }
    } else {
      vendors.values[vendor.handle] = {
        ...vendor,
        count: [product.handle]
      }
    }
  }

 if(product.hasOwnProperty('tags')) {
 for(let tag of product.tags) {
 if(tag.handle) {
 if(topicTags.values[tag.handle]) {
 if(!topicTags.values[tag.handle].count.includes(product.handle)) {
            topicTags.values[tag.handle].count.push(product.handle);
          }
 } else {
 topicTags.values[tag.handle] = {
 ...tag,
 count: [product.handle]
 }
 }
 }
 }
 }

}
```

我们的代码已经变得重复和复杂，让我们通过创建一个处理重复代码的方法来简化它。

用函数`addTopic`创建一个`methods`对象。这需要两个参数:要追加的对象和单数项。例如，它的用法是:

```
if(product.hasOwnProperty('vendor')) {
  this.addTopic(this.topics.vendor, product.vendor, product.handle);
}
```

创建函数并从`hasOwnProperty` if 声明中抽象出逻辑。将两个参数命名为`category`和`item`，并相应地更新代码:

```
methods: {
  addTopic(category, item, handle) {
    if(item.handle) {

      if(category.values[item.handle]) {
        if(!category.values[item.handle].count.includes(handle)) {
          category.values[item.handle].count.push(handle);
        }

      } else {

        category.values[item.handle] = {
          ...item,
          count: [handle]
        }
      }
    }
  }
}
```

更新`filters`计算函数以使用新的`addTopic`方法。删除函数顶部的变量声明，因为它们被直接传递给方法:

```
filters() {
  if(this.categoriesExist) {

    let category = this.categoryProducts(this.slug);

    for(let product of category.productDetails) {

      if(product.hasOwnProperty('vendor')) {
        this.addTopic(this.topics.vendor, product.vendor, product.handle);
      }

      if(product.hasOwnProperty('tags')) {
        for(let tag of product.tags) {
          this.addTopic(this.topics.tags, tag, product.handle);
        }
      }

    }
  }
}
```

在这个函数结束时，返回`this.topics`。虽然我们可以在模板中直接引用`topics`，但是我们需要确保`filters`计算属性被触发:

```
filters() {
  if(this.categoriesExist) {
    ...
  }

  return this.topics;
}
```

在我们继续创建基于各种类型的动态过滤器之前，让我们显示当前的过滤器。

由于`topics`对象是如何设置的，我们可以遍历每个子对象，然后遍历每个子对象的`values`。我们将使用复选框制作过滤器，输入的值是每个过滤器的句柄:

```

template: `<div>
 <div class="filters">
 <div class="filterGroup" v-for="filter in filters">
 <h3>{{ filter.title }}</h3>

 <label class="filter" v-for="value in filter.values">
 <input type="checkbox" :value="value.handle">
 {{ value.title }} ({{ value.count }})
 </label>
 </div> 
 </div>

  <list-categories />
</div>`,
```

为了跟踪检查的内容，我们可以使用一个`v-model`属性。如果有带有相同`v-model`的复选框，Vue 会为每个项目创建一个数组。

向数据对象中的每个`topic`对象添加一个`checked`数组:

```
data() {
  return {
    topics: {
      vendor: {
        title: 'Manufacturer',
        handle: 'vendor',
        checked: [],
        values: {}
      },
      tags: {
        title: 'Tags',
        handle: 'tags',
        checked: [],
        values: {}
      }
    }
  }
}
```

接下来，为每个复选框添加一个`v-model`属性，引用`filter`对象上的这个数组以及一个点击绑定器，引用一个`updateFilters`方法:

```
<div class="filters">
  <div class="filterGroup" v-for="filter in filters">
    <h3>{{ filter.title }}</h3>

    <label class="filter" v-for="value in filter.values">
      <input type="checkbox" :value="value.handle" v-model="filter.checked"  @click="updateFilters">
      {{ value.title }} ({{ value.count }})
    </label>
  </div> 
</div>
```

现在创建一个空方法——我们将在以后配置它:

```
methods: {
    addTopic(category, item) {
      ...
    },

 updateFilters() {

 }
}
```



# 动态创建过滤器

随着我们的固定过滤器被创建和被监视，我们可以抓住机会创建动态过滤器。这些过滤器将观察产品上的`variationTypes`(例如，颜色和尺寸)并再次列出选项–以及每个选项的数量。

为此，我们需要首先遍历产品上的`variationTypes`。在添加任何东西之前，我们需要检查那个变体类型是否存在于`topics`对象上，如果不存在–，我们需要添加一个骨架对象。这扩展了变体(包含了`title`和`handle`，还包含了空的`checked`和`value`属性:

```
filters() {
  if(this.categoriesExist) {

    let category = this.categoryProducts(this.slug);

    for(let product of category.productDetails) {

      if(product.hasOwnProperty('vendor')) {
        this.addTopic(this.topics.vendor, product.vendor);
      }

      if(product.hasOwnProperty('tags')) {
        for(let tag of product.tags) {
          this.addTopic(this.topics.tags, tag);
        }
      }

 Object.keys(product.variationTypes).forEach(vkey => {
 let variation = product.variationTypes[vkey];

 if(!this.topics.hasOwnProperty(variation.handle)) {
 this.topics[variation.handle] = {
 ...variation,
 checked: [],
 values: {}
 }
 }
 });

    }
  }

  return this.topics;
}
```

创建了空对象后，我们现在可以遍历产品对象上的`variationProducts`。对于每一个，我们都可以通过当前变体的句柄来访问变体。从那里，我们可以使用我们的`addTopic`方法在过滤器中包含值(例如，Blue 或 XL ):

```
Object.keys(product.variationTypes).forEach(vkey => {
  let variation = product.variationTypes[vkey];

  if(!this.topics.hasOwnProperty(variation.handle)) {
    this.topics[variation.handle] = {
      ...variation,
      checked: [],
      values: {}
    }
  }

  Object.keys(product.variationProducts).forEach(pkey => {
 let variationProduct = product.variationProducts[pkey]; 
 this.addTopic(
 this.topics[variation.handle],
 variationProduct.variant[variation.handle],      product.handle
 );
 });

});
```

然而，我们确实需要更新我们的`addTopic`方法。这是因为动态属性有一个`value`，而不是一个标题。

给你的`addTopic`方法添加一个`if`语句，检查是否存在一个`value`，如果存在–将其设置为`title`:

```
addTopic(category, item, handle) {
  if(item.handle) {

    if(category.values[item.handle]) {
      if(!category.values[item.handle].count.includes(handle)) {
        category.values[item.handle].count.push(handle);
      }

    } else {

 if(item.hasOwnProperty('value')) {
 item.title = item.value;
 }

      category.values[item.handle] = {
        ...item,
        count: [handle]
      }
    }
  }
}
```

在浏览器中查看应用程序应该会显示您动态添加的过滤器，以及我们添加的原始过滤器。



# 重置过滤器

在类别之间导航时，您会注意到，目前过滤器不会重置。这是因为我们没有清除每次导航之间的过滤器，数组是持久的。这并不理想，因为这意味着它们会随着您的浏览而变长，并且不适用于列出的产品。

为了补救这一点，我们可以创建一个方法来返回我们的默认主题对象，当 slug 更新时，调用该方法来重置`topics`对象。将`topics`对象移动到名为`defaultTopics`的新方法中:

```
methods: {
 defaultTopics() {
 return {
 vendor: {
 title: 'Manufacturer',
 handle: 'vendor',
 checked: [],
 values: {}
 },
 tags: {
 title: 'Tags',
 handle: 'tags',
 checked: [],
 values: {}
 }
 }
 },

  addTopic(category, item) {
    ...
  }

  updateFilters() {

  }
}
```

在`data`函数中，将 topics 的值改为`this.defaultTopics()`以调用该方法:

```
data() {
  return {
    topics: this.defaultTopics()
  }
},
```

最后，添加一个 watch 函数，在`slug`更新时重置 topics 键:

```
watch: {
  slug() {
 this.topics = this.defaultTopics();
 }
}
```



# 在复选框筛选器更改时更新 URL

当与我们的过滤组件交互时，它将更新 URL 查询参数。这允许用户看到过滤器的效果，将它们标记为书签，并在需要时共享 URL。我们已经为分页使用了查询参数，在过滤–时让用户回到第一页是有意义的，因为可能只有一页。

为了构造过滤器的查询参数，我们需要遍历每个过滤器类型，并为每个在`checked`数组中有条目的过滤器类型添加一个新参数。然后我们可以调用一个`router.push()`来更新 URL，进而改变显示的产品。

在您的`updateFilters`方法中创建一个空对象。遍历主题，用选中的项目填充`filters`对象。将路由器中的`query`参数设置为`filters`对象:

```
updateFilters() {
  let filters = {};

 Object.keys(this.topics).forEach(key => {
 let topic = this.topics[key];
 if(topic.checked.length) {
 filters[key] = topic.checked;
 }
 });

 this.$router.push({query: filters});
}
```

选中和取消选中右边的过滤器应该会用选中的项目更新 URL。



# 页面加载时预选过滤器

当加载 URL 中已经有过滤器的类别时，我们需要确保右边的复选框被选中。这可以通过遍历现有的查询参数并向 topics 参数添加任何匹配的键和数组来实现。由于`query`既可以是数组也可以是字符串，我们需要确保被检查的属性无论如何都是数组。我们还需要确保查询关键字确实是一个过滤器，而不是一个页面参数:

```
filters() {
  if(this.categoriesExist) {

    let category = this.categoryProducts(this.slug);

    for(let product of category.productDetails) {
      ...
    }

 Object.keys(this.$route.query).forEach(key => {
      if(Object.keys(this.topics).includes(key)) {
        let query = this.$route.query[key];
        this.topics[key].checked = Array.isArray(query) ? query : [query];
      }
    });
  }

  return this.topics;
}
```

在页面加载时，将检查 URL 中的过滤器。



# 过滤产品

我们的过滤器现在被动态地创建和附加，激活过滤器会更新 URL 中的查询参数。我们现在可以根据 URL 参数显示和隐藏产品了。我们将在产品被传递到`ListProducts`组件之前对其进行过滤。这确保了分页正常工作。

当我们过滤时，打开`ListProducts.js`并为每个列表项添加一个`:key`属性，并使用`handle`的值:

```
<ol :start="pagination.range.from + 1">
  <li v-for="product in paginate(products)" :key="product.handle">
    ...
  </li>
</ol>
```

打开`CategoryPage`视图，在标题为`filtering()`的`methods`对象中创建一个方法，并添加一个`return true`作为开始。该方法应该接受两个参数，一个`product`和`query`对象:

```
methods: {
  filtering(product, query) {

 return true;
 }
}
```

接下来，在`category`计算函数中，如果有查询参数，我们需要过滤产品。然而，我们需要注意，如果页码存在–，我们不会触发过滤器，因为这也是一个查询。

创建一个名为`filters`的新变量，它是来自 route 的查询对象的副本。接下来，如果 page 参数存在，`delete`它来自我们的新对象。从那里，我们可以检查查询对象是否有任何其他内容，如果有，在我们的产品数组–上运行本地 JavaScript `filter()`函数，将产品和新的查询/过滤器对象传递给我们的方法:

```
category() {
  if(this.categoriesExist) {
    let category = this.categoryProducts(this.slug),
 filters = Object.assign({}, this.$route.query);

 if(Object.keys(filters).length && filters.hasProperty('page')) {
 delete filters.page;
 }

 if(Object.keys(filters).length) {
 category.productDetails = category.productDetails.filter(
 p => this.filtering(p, filters)
 );
 }

    if(!category) {
      this.categoryNotFound = true;
    }
    return category;
  }
}
```

刷新你的应用程序以确保产品仍然显示。

要过滤产品，需要相当复杂的过程。我们要检查一个属性是否在查询参数中；如果是，我们设置一个占位符值`false`。如果产品的属性与查询参数的属性匹配，我们将占位符设置为`true`。然后，我们对每个查询参数重复这一过程。完成后，我们只显示符合所有标准的产品。

我们将要构建的方式允许产品在类别中有`OR`，但是有不同部分的`AND`。例如，如果用户选择许多颜色(红色和绿色)和一个标签(配件)，它将显示所有红色或绿色配件的产品。

我们的过滤是用标签、供应商和动态过滤器创建的。由于其中两个属性是固定的，我们必须首先检查它们。动态过滤器将通过重建其建造方式进行验证。

创建一个`hasProperty`对象，这将是我们的占位符对象，用于跟踪产品的查询参数。我们将从`vendor`–开始，因为这是最简单的属性。

我们首先循环查询属性–，以防有多个属性(例如，red 和 green)。接下来，我们需要确认`vendor`存在于`query`–中，如果存在，那么我们将`hasProperty`对象中的一个供应商属性设置为`false`。然后，我们检查供应商句柄是否与查询属性相同。如果匹配，我们将`hasProperty.vendor`属性改为`true`:

```
filtering(product, query) {
  let display = false,
 hasProperty = {};

 Object.keys(query).forEach(key => {
 let filter = Array.isArray(query[key]) ? query[key] : [query[key]];

 for(attribute of filter) {
 if(key == 'vendor') {

 hasProperty.vendor = false;
 if(product.vendor.handle == attribute) {
 hasProperty.vendor = true;
 }

 }      }
 });

 return display;
}
```

这将使用供应商是否匹配所选过滤器来更新`hasProperty`对象。我们可以用`tags`–重复功能，记住产品上的标签是我们需要过滤的对象。

还需要检查由过滤器构建的动态属性。这是通过检查每个`variationProduct`上的变量对象来完成的，如果匹配就更新`hasProperty`对象:

```
filtering(product, query) {
  let display = false,
    hasProperty = {};

    Object.keys(query).forEach(key => {
      let filter = Array.isArray(query[key]) ? query[key] : [query[key]];

      for(attribute of filter) {
        if(key == 'vendor') {

          hasProperty.vendor = false;
          if(product.vendor.handle == attribute) {
            hasProperty.vendor = true;
          }

        } else if(key == 'tags') {
 hasProperty.tags = false;

 product[key].map(key => {
 if(key.handle == attribute) {
 hasProperty.tags = true;
 }
 });

 } else {
 hasProperty[key] = false;

 let variant = product.variationProducts.map(v => {
 if(v.variant[key] && v.variant[key].handle == attribute) {
 hasProperty[key] = true;
 }
 });
 }
 }
    });

  return display;
}
```

最后，我们需要检查`hasProperty`对象的每个属性。如果所有值都设置为`true`，我们可以将产品的显示设置为`true`–表示将会显示。如果其中一个是`false`，产品将不会显示，因为它不符合所有标准:

```
filtering(product, query) {
  let display = false,
    hasProperty = {};

    Object.keys(query).forEach(key => {
      let filter = Array.isArray(query[key]) ? query[key] : [query[key]];

      for(attribute of filter) {
        if(key == 'vendor') {

          hasProperty.vendor = false;
          if(product.vendor.handle == attribute) {
            hasProperty.vendor = true;
          }

        } else if(key == 'tags') {
          hasProperty.tags = false;

          product[key].map(key => {
            if(key.handle == attribute) {
              hasProperty.tags = true;
            }
          });

        } else {
          hasProperty[key] = false;

          let variant = product.variationProducts.map(v => {
            if(v.variant[key] && v.variant[key].handle == attribute) {
              hasProperty[key] = true;
            }
          });
        }
      }

 if(Object.keys(hasProperty).every(key => hasProperty[key])) {
 display = true;
 }

    });

  return display;
}
```

我们现在已经成功筛选出产品列表。在浏览器中查看您的应用程序并更新过滤器，注意每次点击时产品是如何显示和隐藏的。请注意，即使您按下“刷新”,也只会显示筛选出的产品。



# 摘要

在本章中，我们创建了一个类别列表页面，允许用户查看一个类别中的所有产品。这个列表可以随着顺序的改变而分页。我们还创建了一个过滤组件，允许用户缩小结果范围。

现在我们的产品可以浏览、过滤和查看，我们可以继续制作购物车和结账页面。